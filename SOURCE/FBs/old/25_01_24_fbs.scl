TYPE "UDT_BlockWave"
VERSION : 0.1
   STRUCT
      Ob_PWM_10Hz : Bool;
      Ob_PWM_5Hz : Bool;
      Ob_PWM_2Hz : Bool;
      Ob_PWM_1Hz : Bool;
      Ob_PWM_0_5Hz : Bool;
      Ob_PWM_0_2Hz : Bool;
      Ob_PWM_0_1Hz : Bool;
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "FB_UTIL_TON_Sec"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
   VAR_INPUT 
      Ib_In : Bool;
      Ii_tValue : Int;
      Ii_Base : Int;
      Ib_Hold : Bool;
   END_VAR

   VAR_OUTPUT 
      Oi_tmrValue : Int;
      Ob_Out : Bool;
   END_VAR

   VAR 
      di_tmrSecVal : DInt;
      di_tmrValue : DInt;
      di_AuxValue : Int;
   END_VAR


BEGIN
	(*======================================================================================================================  
	Purpose: Reditech standard utility block for a time ON delay, max setpoint = 30 000 in seconds, minutes or hours
	----------------------------------------------------------------------------------------------------------------------
	Date (dd MMM yyyy)   Developer                   Version Comments/Reason for change
	..................   .........                   ....... ..........................
	13 APR 2016          Harm Bastiaansen            01      Rockwell initial version 
	01 Nov 2018          Bram Verheyen               03      changed the pulse to an internal pulse using the blokwave
	                                                         --> to improve accuratie when the counter is called in a cyclic OB/task
	----------------------------------------------------------------------------------------------------------------------
	  principle : 
	                          ___________________             
	       input :     ______|                   |______
	 
	                   ______                     ______
	                         \                   |
	                          \                  |
	       counter :           \                 |
	                            \________________|
	                              _______________
	       output :    __________|               |______
	  
	       time :            |<->|
	 
	====================================================================================================================== *)
	
	(*  copy and check setpoint value *)
	#di_AuxValue := #Ii_tValue; (*  copy value to auxiliary for check *)
	IF (#di_AuxValue < 0) THEN   (*  limit time value between 0 and 30 000 *)
	    #di_AuxValue := 0;
	END_IF;
	IF (#di_AuxValue > 30000) THEN
	    #di_AuxValue := 30000;
	END_IF;
	(*  on delay timer control, only if value > 0 *)
	IF (#di_AuxValue > 0) THEN
	    IF NOT #Ib_In THEN
	        #Oi_tmrValue := #di_AuxValue;
	    END_IF;
	    
	    IF #Ib_In AND "Clock_1Hz" AND NOT #Ib_Hold AND #Oi_tmrValue > 0 THEN
	        #Oi_tmrValue := #Oi_tmrValue - 1;
	    END_IF;
	    
	    #Ob_Out := #Oi_tmrValue <= 0;
	ELSE
	    #Ob_Out := #Ib_In;
	    #Oi_tmrValue := 0;
	END_IF;
	(*
	    (*  initialize timer value when timer not activated *)
	    IF NOT #Ib_In THEN
	        #di_tmrSecVal := #di_AuxValue;
	        #di_tmrValue := 10;
	    END_IF;
	    
	    (*  count down timer *)
	    IF #Ib_In AND "b_100ms_Pulse" AND NOT #Ib_Hold THEN
	        #di_tmrValue := #di_tmrValue - 1;
	        (*  reset milliseconds counter to 9 after reaching 0 *)
	        IF ((#di_tmrValue < 0) AND (#di_tmrSecVal >= 0)) THEN
	            #di_tmrValue := 9;
	            #di_tmrSecVal := #di_tmrSecVal - 1;
	        END_IF;
	    END_IF;
	
	    (*  limit timer to 0 (to prevent big negative values and overflow to big positive values) *)
	    IF (#di_tmrValue < 0) THEN
	        #di_tmrSecVal := 0;
	        #di_tmrValue := 0;
	    END_IF;
	    (*  check timer value *)
	    #Ob_Out := ((#di_tmrValue <= 0) AND (#di_tmrSecVal <= 0));
	
	ELSE (*  when timer setpoint value = 0 => output = input and counter = 0 *)
	    #Ob_Out := #Ib_In;
	    #di_tmrValue := 0;
	    #di_tmrSecVal := 0;
	END_IF;
	*)
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_UTIL_Totalizer"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
   VAR_INPUT 
      Ir_ProcValFlow : Real;   // Flow measurement
      Ib_1sPulse : Bool;   // Pulse every second
      Ib_RstVol : Bool;   // Reset the volume counter
   END_VAR

   VAR_OUTPUT 
      Or_VolTot : Real;   // Total volume
      Or_VolRst : Real;   // Volume from last reset
      Or_VolTotDint : DInt;
      Or_VolRstDint : DInt;
   END_VAR

   VAR 
      b_CfgEnExtPulse { ExternalVisible := 'False'} : Bool;   // External pulse available
      b_CfgSpare01 { ExternalVisible := 'False'} : Bool;
      b_CfgSpare02 { ExternalVisible := 'False'} : Bool;
      b_CfgSpare03 { ExternalVisible := 'False'} : Bool;
      b_CfgSpare04 { ExternalVisible := 'False'} : Bool;
      b_CfgSpare05 { ExternalVisible := 'False'} : Bool;
      b_CfgSpare06 { ExternalVisible := 'False'} : Bool;
      b_CfgSpare07 { ExternalVisible := 'False'} : Bool;
      b_CfgSpare08 { ExternalVisible := 'False'} : Bool;
      b_CfgSpare09 { ExternalVisible := 'False'} : Bool;
      b_CfgSpare10 { ExternalVisible := 'False'} : Bool;
      b_CfgSpare11 { ExternalVisible := 'False'} : Bool;
      b_CfgSpare12 { ExternalVisible := 'False'} : Bool;
      b_CfgSpare13 { ExternalVisible := 'False'} : Bool;
      b_CfgSpare14 { ExternalVisible := 'False'} : Bool;
      b_CfgSpare15 { ExternalVisible := 'False'} : Bool;
      b_ExtPulseOld { ExternalVisible := 'False'} : Bool;
   END_VAR

   VAR_TEMP 
      Ir_ProcValueDint : DInt;
   END_VAR


BEGIN
	// =============================================================================================================================  
	// Purpose: Reditech standard typical for calculating volume from flow
	// -----------------------------------------------------------------------------------------------------------------------------
	// Date (dd MMM yyyy)   Developer                   Version Comments/Reason for change
	// ..................   .........                   ....... ..........................
	// 24 okt 2018          Matthias De Staelen         01      Initial volume counter (creation)
	//
	// --------------------------------------------------- Initial AXM Release  ----------------------------------------------------
	// =============================================================================================================================
	
	//Converting the input raw value Real in Dint variable.
	#Ir_ProcValueDint :=  REAL_TO_DINT(#Ir_ProcValFlow);
	
	//Trigger the counter, if the raw value is higher than the minimum (2).
	IF (#Ib_1sPulse) AND (#b_ExtPulseOld = 0) AND #Ir_ProcValueDint > 2 THEN
	         #Or_VolRstDint := #Or_VolRstDint + #Ir_ProcValueDint;
	         #Or_VolTotDint := #Or_VolTotDint + #Ir_ProcValueDint;
	         
	         #Or_VolRst := DINT_TO_REAL(#Or_VolRstDint);
	         #Or_VolRst := #Or_VolRst / 3600;
	        
	         #Or_VolTot := DINT_TO_REAL(#Or_VolTotDint);
	         #Or_VolTot := #Or_VolTot / 3600;
	END_IF;
	     
	#b_ExtPulseOld := #Ib_1sPulse;
	
	//If the reset counter action is performed, only reset the temporary counter.
	IF #Ib_RstVol THEN
	    #Or_VolRstDint := 0;
	    #Or_VolRst := 0.0;
	END_IF;
	
	
	
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_UTIL_TON_Min"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
   VAR_INPUT 
      Ib_In : Bool;
      Ii_tValue : Int;
      Ii_Base : Int;
      Ib_Hold : Bool;
   END_VAR

   VAR_OUTPUT 
      Oi_tmrValue : Int;
      Ob_Out : Bool;
   END_VAR

   VAR 
      di_tmrSecVal : DInt;
      di_tmrValue : DInt;
      di_AuxValue : Int;
   END_VAR


BEGIN
	(*======================================================================================================================  
	Purpose: Reditech standard utility block for a time ON delay, max setpoint = 30 000 in seconds, minutes or hours
	----------------------------------------------------------------------------------------------------------------------
	Date (dd MMM yyyy)   Developer                   Version Comments/Reason for change
	..................   .........                   ....... ..........................
	13 APR 2016          Harm Bastiaansen            01      Rockwell initial version 
	01 Nov 2018          Bram Verheyen               03      changed the pulse to an internal pulse using the blokwave
	                                                         --> to improve accuratie when the counter is called in a cyclic OB/task
	----------------------------------------------------------------------------------------------------------------------
	  principle : 
	                          ___________________             
	       input :     ______|                   |______
	 
	                   ______                     ______
	                         \                   |
	                          \                  |
	       counter :           \                 |
	                            \________________|
	                              _______________
	       output :    __________|               |______
	  
	       time :            |<->|
	 
	====================================================================================================================== *)
	
	(*  copy and check setpoint value *)
	#di_AuxValue := #Ii_tValue*60; (*[SI] = Minutes)  copy value to auxiliary for check *)
	IF (#di_AuxValue < 0) THEN   (*  limit time value between 0 and 30 000 *)
	    #di_AuxValue := 0;
	END_IF;
	IF (#di_AuxValue > 30000) THEN
	    #di_AuxValue := 30000;
	END_IF;
	(*  on delay timer control, only if value > 0 *)
	IF (#di_AuxValue > 0) THEN
	    IF NOT #Ib_In THEN
	        #Oi_tmrValue := #di_AuxValue;
	    END_IF;
	    
	    IF #Ib_In AND "Clock_1Hz" AND NOT #Ib_Hold AND #Oi_tmrValue > 0 THEN
	        #Oi_tmrValue := #Oi_tmrValue - 1;
	    END_IF;
	    
	    #Ob_Out := #Oi_tmrValue <= 0;
	ELSE
	    #Ob_Out := #Ib_In;
	    #Oi_tmrValue := 0;
	END_IF;
	(*
	    (*  initialize timer value when timer not activated *)
	    IF NOT #Ib_In THEN
	        #di_tmrSecVal := #di_AuxValue;
	        #di_tmrValue := 10;
	    END_IF;
	    
	    (*  count down timer *)
	    IF #Ib_In AND "b_100ms_Pulse" AND NOT #Ib_Hold THEN
	        #di_tmrValue := #di_tmrValue - 1;
	        (*  reset milliseconds counter to 9 after reaching 0 *)
	        IF ((#di_tmrValue < 0) AND (#di_tmrSecVal >= 0)) THEN
	            #di_tmrValue := 9;
	            #di_tmrSecVal := #di_tmrSecVal - 1;
	        END_IF;
	    END_IF;
	
	    (*  limit timer to 0 (to prevent big negative values and overflow to big positive values) *)
	    IF (#di_tmrValue < 0) THEN
	        #di_tmrSecVal := 0;
	        #di_tmrValue := 0;
	    END_IF;
	    (*  check timer value *)
	    #Ob_Out := ((#di_tmrValue <= 0) AND (#di_tmrSecVal <= 0));
	
	ELSE (*  when timer setpoint value = 0 => output = input and counter = 0 *)
	    #Ob_Out := #Ib_In;
	    #di_tmrValue := 0;
	    #di_tmrSecVal := 0;
	END_IF;
	*)
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_UTIL_Pulse_Width_Sec"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
   VAR_INPUT 
      Ib_ReqPulse : Bool;   // Input request
      Ib_Clock : Bool;   // Cyclic pulse 1 sec
      Ii_PulseWidth_Setpoint : UInt;   // Output pulse width in seconds
   END_VAR

   VAR_OUTPUT 
      Ob_ReqEqp : Bool;
   END_VAR

   VAR 
      Ii_TotSec : UInt;   // Time totalizer
      b_PulseHold : Bool;
   END_VAR


BEGIN
	//Author: Ivan Galhardoni
	//Date: 2020/July/01
	//Revision: 01
	//Purpose: Output pulse width duration with request.
	
	//Every input request, set output high, start counting, and erase output after time
	IF #Ib_ReqPulse AND NOT #b_PulseHold THEN
	    #b_PulseHold := TRUE;
	    #Ii_TotSec := 0;
	END_IF;
	
	//Every input pulse, count 1 unit for the totalizer (Count 1 sec for each pulse)
	IF #Ib_Clock AND #Ii_TotSec < #Ii_PulseWidth_Setpoint AND #b_PulseHold THEN
	    #Ii_TotSec := #Ii_TotSec + 1;
	END_IF;
	
	//If the setpoint time has been reached and there is a request
	IF #Ii_TotSec >= #Ii_PulseWidth_Setpoint AND #b_PulseHold THEN
	    #Ii_TotSec := 0;
	    #b_PulseHold := FALSE;
	END_IF;
	
	#Ob_ReqEqp := #b_PulseHold;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_UTIL_Volume"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
   VAR_INPUT 
      Ib_Compare : Bool;   // compare while compare is true
      Ib_ResetCounter : Bool;   // Reset countervalue
      Ir_Procvalue : Real;   // proces value of AV totaliser
      Ir_compValue : Real;   // Value to compare with
   END_VAR

   VAR_OUTPUT 
      Ob_Grt : Bool;   // true if greater then
      Or_actDiff : Real;   // actual difference
   END_VAR

   VAR 
      b_prevStart { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // previous start bool for rising edge
      b_start { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   // this start for rising edge
      r_prevValue { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   // previous value for compare
      r_prevActDiff : Real;
   END_VAR


BEGIN
	// ====================================================================================================================== 
	// Purpose: Reditech standard utility block for controlling DOSING VOLUME
	// ----------------------------------------------------------------------------------------------------------------------
	// Date (dd MMM yyyy)   Developer                                   Version Comments/Reason for change
	// ..................   .........                                   ....... ..........................
	// 10 DEC 2018          ROBIN CARDINAELS                           01      Initial (creation)
	
	// ======================================================================================================================
	
	
	IF #Ib_Compare THEN
	    #b_start := #Ib_Compare;
	    IF NOT #b_prevStart AND #b_start THEN
	        #r_prevValue := #Ir_Procvalue;
	        #r_prevActDiff := #Or_actDiff;
	    END_IF;
	    #Or_actDiff := #r_prevActDiff + (#Ir_Procvalue - #r_prevValue);
	    IF #Or_actDiff >= #Ir_compValue THEN
	        #Ob_Grt := true;
	    ELSE
	        #Ob_Grt := false;
	    END_IF;
	    #b_prevStart := #b_start;
	ELSE
	    #b_prevStart:=#b_start:=#Ib_Compare;
	
	END_IF;
	IF #Ib_ResetCounter THEN
	    #Or_actDiff := 0;
	    #Ob_Grt := false;
	END_IF;
	
	    
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_UTIL_GEN_FUNCTIONS"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
   VAR_INPUT 
      Ist_Blockwave : "UDT_BlockWave";
   END_VAR

   VAR_OUTPUT 
      Ob_PWM_10Hz : Bool;
      Ob_PWM_5Hz : Bool;
      Ob_PWM_2Hz : Bool;
      Ob_PWM_1Hz : Bool;
      Ob_PWM_0_5Hz : Bool;
      Ob_PWM_0_2Hz : Bool;
      Ob_PWM_0_1Hz : Bool;
      Ob_Puls_100ms : Bool;
      Ob_Puls_200ms : Bool;
      Ob_Puls_500ms : Bool;
      Ob_Puls_1sec : Bool;
      Ob_Puls_2sec : Bool;
      Ob_Puls_5sec : Bool;
      Ob_Puls_10sec : Bool;
      Ob_Always_One : Bool;
      Ob_Always_Zero : Bool;
      Oi_Always_Zero : Int;
      Od_Always_Zero : DInt;
      Or_Always_Zero : Real;
   END_VAR

   VAR 
      Copy_PWM_0_1Hz : Bool;
      Copy_PWM_0_2Hz : Bool;
      Copy_PWM_0_5Hz : Bool;
      Copy_PWM_1Hz : Bool;
      Copy_PWM_2Hz : Bool;
      Copy_PWM_5Hz : Bool;
      Copy_PWM_10Hz : Bool;
   END_VAR


BEGIN
	(*=============================================================================================================================  
	Purpose: Reditech standard utility for general functions
	-----------------------------------------------------------------------------------------------------------------------------
	Date (dd MMM yyyy)   Developer                           Version Comments/Reason for change
	..................   .........                           ....... ..........................
	10 OKT 2017          Bram Verheyen                       01      Rockwell Initial 
	
	                       
	=============================================================================================================================*)
	
	(* ---------------------------------------*)
	(* Block wave signals *)
	(* ---------------------------------------*)
	#Ob_PWM_10Hz := #Ist_Blockwave.Ob_PWM_10Hz;
	#Ob_PWM_5Hz := #Ist_Blockwave.Ob_PWM_5Hz;
	#Ob_PWM_2Hz := #Ist_Blockwave.Ob_PWM_2Hz;
	#Ob_PWM_1Hz := #Ist_Blockwave.Ob_PWM_1Hz;
	#Ob_PWM_0_5Hz := #Ist_Blockwave.Ob_PWM_0_5Hz;
	#Ob_PWM_0_2Hz := #Ist_Blockwave.Ob_PWM_0_2Hz;
	#Ob_PWM_0_1Hz := #Ist_Blockwave.Ob_PWM_0_1Hz;
	
	(* ---------------------------------------*)
	(* Generating pulses using the block wave signals *)
	(* ---------------------------------------*)
	IF #Ob_PWM_10Hz AND NOT #Copy_PWM_10Hz THEN
	    #Ob_Puls_100ms := 1;
	ELSE
	    #Ob_Puls_100ms := 0;
	END_IF;
	
	IF #Ob_PWM_5Hz AND NOT #Copy_PWM_5Hz THEN
	    #Ob_Puls_200ms := 1;
	ELSE
	    #Ob_Puls_200ms := 0;
	END_IF;
	
	IF #Ob_PWM_2Hz AND NOT #Copy_PWM_2Hz THEN
	    #Ob_Puls_500ms := 1;
	ELSE
	    #Ob_Puls_500ms := 0;
	END_IF;
	
	IF #Ob_PWM_1Hz AND NOT #Copy_PWM_1Hz THEN
	    #Ob_Puls_1sec := 1;
	ELSE
	    #Ob_Puls_1sec := 0;
	END_IF;
	
	IF #Ob_PWM_0_5Hz AND NOT #Copy_PWM_0_5Hz THEN
	    #Ob_Puls_2sec := 1;
	ELSE
	    #Ob_Puls_2sec := 0;
	END_IF;
	
	IF #Ob_PWM_0_2Hz AND NOT #Copy_PWM_0_2Hz THEN
	    #Ob_Puls_5sec := 1;
	ELSE
	    #Ob_Puls_5sec := 0;
	END_IF;
	
	IF #Ob_PWM_0_1Hz AND NOT #Copy_PWM_0_1Hz THEN
	    #Ob_Puls_10sec := 1;
	ELSE
	    #Ob_Puls_10sec := 0;
	END_IF;
	
	
	#Copy_PWM_10Hz := #Ob_PWM_10Hz;
	#Copy_PWM_5Hz := #Ob_PWM_5Hz;
	#Copy_PWM_2Hz := #Ob_PWM_2Hz;
	#Copy_PWM_1Hz := #Ob_PWM_1Hz;
	#Copy_PWM_0_5Hz := #Ob_PWM_0_5Hz;
	#Copy_PWM_0_2Hz := #Ob_PWM_0_2Hz;
	#Copy_PWM_0_1Hz := #Ob_PWM_0_1Hz;
	
	
	(* ---------------------------------------*)
	(* Constants *)
	(* ---------------------------------------*)
	#Ob_Always_One := 1;
	#Ob_Always_Zero := 0;
	#Oi_Always_Zero := 0;
	#Od_Always_Zero := 0;
	#Or_Always_Zero := 0.0;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_UTIL_BLOCKWAVEGENERATOR"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
   VAR_OUTPUT 
      OstBlockwave : "UDT_BlockWave";
   END_VAR

   VAR 
      d_Counter_0_1Hz : DInt;
      d_Counter_0_2Hz : DInt;
      d_Counter_0_5Hz : DInt;
      d_Counter_1Hz : DInt;
      d_Counter_2Hz : DInt;
      d_Counter_5Hz : DInt;
      d_Counter_10Hz : DInt;
      Ob_PWM_10Hz : Bool;
      Ob_PWM_5Hz : Bool;
      Ob_PWM_2Hz : Bool;
      Ob_PWM_1Hz : Bool;
      Ob_PWM_0_5Hz : Bool;
      Ob_PWM_0_2Hz : Bool;
      Ob_PWM_0_1Hz : Bool;
   END_VAR


BEGIN
	(*=============================================================================================================================  
	Purpose: Reditech standard utility for generating blockwave signals
	-----------------------------------------------------------------------------------------------------------------------------
	Date (dd MMM yyyy)   Developer                           Version Comments/Reason for change
	..................   .........                           ....... ..........................
	10 OKT 2017         Bram Verheyen                      01      Rockwell Initial 
	17 May 2018         Robin Cardinaels                   02      Added blockwave udt output
	                             
	=============================================================================================================================*)
	
	
	(* ---------------------------------------*)
	(* Run timers (counters) *)
	(* ---------------------------------------*)
	#d_Counter_10Hz := #d_Counter_10Hz + 1;
	#d_Counter_5Hz := #d_Counter_5Hz + 1;
	#d_Counter_2Hz := #d_Counter_2Hz + 1;
	#d_Counter_1Hz := #d_Counter_1Hz + 1;
	#d_Counter_0_5Hz := #d_Counter_0_5Hz + 1;
	#d_Counter_0_2Hz := #d_Counter_0_2Hz + 1;
	#d_Counter_0_1Hz := #d_Counter_0_1Hz + 1;
	
	
	(* ---------------------------------------*)
	(* Genrating the block wave signals *)
	(* ---------------------------------------*)
	IF #d_Counter_10Hz <= 1 THEN
	    #OstBlockwave.Ob_PWM_10Hz := 0;
	ELSE
	    #OstBlockwave.Ob_PWM_10Hz := 1;
	END_IF;
	
	IF #d_Counter_5Hz <= 2 THEN
	    #OstBlockwave.Ob_PWM_5Hz := 0;
	ELSE
	    #OstBlockwave.Ob_PWM_5Hz := 1;
	END_IF;
	
	IF #d_Counter_2Hz <= 5 THEN
	    #OstBlockwave.Ob_PWM_2Hz := 0;
	ELSE
	    #OstBlockwave.Ob_PWM_2Hz := 1;
	END_IF;
	
	IF #d_Counter_1Hz <= 10 THEN
	    #OstBlockwave.Ob_PWM_1Hz := 0;
	ELSE
	    #OstBlockwave.Ob_PWM_1Hz := 1;
	END_IF;
	
	IF #d_Counter_0_5Hz <= 20 THEN
	    #OstBlockwave.Ob_PWM_0_5Hz := 0;
	ELSE
	    #OstBlockwave.Ob_PWM_0_5Hz := 1;
	END_IF;
	
	IF #d_Counter_0_2Hz <= 40 THEN
	    #OstBlockwave.Ob_PWM_0_2Hz := 0;
	ELSE
	    #OstBlockwave.Ob_PWM_0_2Hz := 1;
	END_IF;
	
	IF #d_Counter_0_1Hz <= 100 THEN
	    #OstBlockwave.Ob_PWM_0_1Hz := 0;
	ELSE
	    #OstBlockwave.Ob_PWM_0_1Hz := 1;
	END_IF;
	
	
	
	(* ---------------------------------------*)
	(* Reset Counters after one block cycle *)
	(* ---------------------------------------*)
	IF #d_Counter_10Hz = 2 THEN
	    #d_Counter_10Hz := 0;
	END_IF;
	
	IF #d_Counter_5Hz = 4 THEN
	    #d_Counter_5Hz := 0;
	END_IF;
	
	IF #d_Counter_2Hz = 10 THEN
	    #d_Counter_2Hz := 0;
	END_IF;
	
	IF #d_Counter_1Hz = 20 THEN
	    #d_Counter_1Hz := 0;
	END_IF;
	
	IF #d_Counter_0_5Hz = 40 THEN
	    #d_Counter_0_5Hz := 0;
	END_IF;
	
	IF #d_Counter_0_2Hz = 80 THEN
	    #d_Counter_0_2Hz := 0;
	END_IF;
	
	IF #d_Counter_0_1Hz = 200 THEN
	    #d_Counter_0_1Hz := 0;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_UTIL_LimLes"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
   VAR_INPUT 
      Ir_ProcVal : Real;   //  Input value from process
      Ii_ParOnDel : Int;   //  On delay time
      Ir_ParHys : Real;   //  Hysterese
      Ir_ParSp : Real;   //  Setpoint
      Ib_DisAlm : Bool;   //  Disable alarm
      Ib_Rst : Bool;   //  Reset alarm
   END_VAR

   VAR_OUTPUT 
      Ob_Lvl : Bool;   //  Level reached
      Ob_DelayLvl : Bool;
      Ob_AlmWrn : Bool;   //  Alarm / warning
   END_VAR

   VAR_IN_OUT 
      IOi_OnDelAct : Int;   //  Running on delay time
      IOi_OnDelActAlm : Int;
   END_VAR

   VAR 
      Time_Delay : "FB_UTIL_TON_Sec";
      Time_Alm : "FB_UTIL_TON_Sec";
      b_AlmOn : Bool;
      b_DelayOn : Bool;
   END_VAR


BEGIN
	(*======================================================================================================================  
	Purpose: Reditech standard utility block for alarm when a value is greater than its limit
	----------------------------------------------------------------------------------------------------------------------
	Date (dd MMM yyyy)   Developer                   Version Comments/Reason for change
	..................   .........                   ....... ..........................
	06  NOV  2018        Kevin Mors                    01     Siemens initial version
	04  JAN  2019        Kevin Mors                    02     Added delayed level
	09  JAN  2019        Bram Verheyen                 03     Full review
	----------------------------------------------------------------------------------------------------------------------
	  principle : 
	                 ______                         _______________
	       PV:             \                       /
	                        \                     /
	       HH:       ________\___________________/_________________
	                          \                 /  
	                           \_______________/                    
	                                                        
	                          ___________________    
	       Ob_Lvl :    ______|                   |______       
	                              ____________________
	       Ob_Alm :    __________|                    |_______
	====================================================================================================================== *)
	
	// Check level low-low (LL)
	IF (#Ir_ProcVal < #Ir_ParSp) THEN
	    #Ob_Lvl := TRUE;
	END_IF;
	IF (#Ir_ProcVal >= #Ir_ParSp) THEN
	    #Ob_Lvl := FALSE;
	END_IF;
	
	// Check level Low-low (LL) with time delay
	#Time_Delay(Ib_In := #Ob_Lvl AND NOT #Ib_DisAlm,
	            Ii_tValue := #Ii_ParOnDel,
	            Ob_Out => #Ob_DelayLvl,
	            Oi_tmrValue => #IOi_OnDelAct);
	
	// Check level Low-Low (LL) with time delay for alarm
	#Time_Alm(Ib_In := #Ob_Lvl AND NOT #Ib_DisAlm,
	          Ii_tValue := #Ii_ParOnDel);
	
	// Set alarm with a time delay
	IF #Time_Alm.Ob_Out THEN
	    #Ob_AlmWrn := true;
	END_IF;
	
	// Reset Alarm
	IF ((#Ir_ProcVal > (#Ir_ParSp + #Ir_ParHys)) OR #Ib_DisAlm) AND #Ib_Rst THEN
	    #Ob_AlmWrn := FALSE;
	END_IF;
	
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_UTIL_LimGrt"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
   VAR_INPUT 
      Ir_ProcVal : Real;   //  Input value from process
      Ii_ParOnDel : Int;   //  On delay time
      Ir_ParHys : Real;   //  Hysterese
      Ir_ParSp : Real;   //  Setpoint
      Ib_DisAlm : Bool;   //  Disable alarm
      Ib_Rst : Bool;   //  Reset alarm
   END_VAR

   VAR_OUTPUT 
      Ob_Lvl : Bool;   //  Level reached
      Ob_DelayLvl : Bool;
      Ob_AlmWrn : Bool;   //  Alarm / warning
   END_VAR

   VAR_IN_OUT 
      IOi_OnDelAct : Int;   //  Running on delay time
      IOi_OnDelActAlm : Int;
   END_VAR

   VAR 
      Time_Delay : "FB_UTIL_TON_Sec";
      Time_Alm : "FB_UTIL_TON_Sec";
      b_AlmOn : Bool;
      b_Delay : Bool;
   END_VAR


BEGIN
	(*======================================================================================================================  
	Purpose: Reditech standard utility block for alarm when a value is greater than its limit
	----------------------------------------------------------------------------------------------------------------------
	Date (dd MMM yyyy)   Developer                   Version Comments/Reason for change
	..................   .........                   ....... ..........................
	06  NOV  2018        Kevin Mors                    01     Siemens initial version
	04  JAN  2019        Kevin Mors                    02     Added delayed level
	09  JAN  2019        Bram Verheyen                 03     Full review
	----------------------------------------------------------------------------------------------------------------------
	  principle : 
	                           _________________
	                          /                 \
	       HH:       ________/___________________\_________________
	                        /                     \
	       PV:       ______/                       \________________
	                                                        
	                          ____________________    
	       Ob_Lvl :    ______|                    |______       
	                              ____________________
	       Ob_Alm :    __________|                    |_______ 
	====================================================================================================================== *)
	
	// Check level High-high (HH)
	IF (#Ir_ProcVal > #Ir_ParSp) THEN
	    #Ob_Lvl := TRUE;
	END_IF;
	IF (#Ir_ProcVal <= #Ir_ParSp) THEN
	    #Ob_Lvl := FALSE;
	END_IF;
	
	// Check level High-high (HH) with time delay
	#Time_Delay(Ib_In := #Ob_Lvl,
	            Ii_tValue := #Ii_ParOnDel,
	            Ob_Out => #Ob_DelayLvl,
	            Oi_tmrValue => #IOi_OnDelAct);
	
	// Check level High-high (HH) with time delay for alarm
	#Time_Alm(Ib_In := #Ob_Lvl AND NOT #Ib_DisAlm,
	          Ii_tValue := #Ii_ParOnDel);
	
	// Set alarm with a time delay
	IF #Time_Alm.Ob_Out THEN
	    #Ob_AlmWrn := true;
	END_IF;
	
	// Reset Alarm
	IF ((#Ir_ProcVal < (#Ir_ParSp - #Ir_ParHys)) OR #Ib_DisAlm) AND #Ib_Rst THEN
	    #Ob_AlmWrn := FALSE;
	END_IF;
	
	
	
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_UTIL_Work_H"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
   VAR_INPUT 
      Ib_On { ExternalVisible := 'False'} : Bool;   //  when 1, increase counters
      Ib_Reset { ExternalVisible := 'False'} : Bool;   //  command reset counters
      Ii_LimitH { ExternalVisible := 'False'} : Int;   //  Limit in hours, if 0 => no limit
      Ib_Pls1S { ExternalVisible := 'False'} : Bool;   //  Pulse : every second
   END_VAR

   VAR_OUTPUT 
      Ob_AbsLim { ExternalVisible := 'False'} : Bool;
      Ob_LimitH { ExternalVisible := 'False'} : Bool;   //  LimitH reached
   END_VAR

   VAR_IN_OUT 
      IOdi_cntSec : DInt;   //  absolute counter in seconds
      IOdi_ResultHours : DInt;   //  Result in hours
      IOdi_ResultSec : DInt;   //  Result in seconds
      IOdi_ResultMin : DInt;   //  Result in minutes
   END_VAR

   VAR 
      b_PulsFla : Bool;
   END_VAR

   VAR_TEMP 
      b_AbsLim : Bool;
      i_modulo : Int;
   END_VAR


BEGIN
	// ====================================================================================================================== 
	// Purpose: Reditech standard utility block for controlling the working hours
	// ----------------------------------------------------------------------------------------------------------------------
	// Date (dd MMM yyyy)   Developer                                   Version Comments/Reason for change
	// ..................   .........                                   ....... ..........................
	// 20 OCT 2016          Bert Drijkoningen                           01      Initial (creation)
	// 03 Aug 2017          Jayson Kurik                                02      Changed it to FB to match Schneider and 
	//                                                                          Rockwell typicals
	// 24 Okt 2018          Matthias De Staelen                         03      Changed outputtype to Dint
	// ======================================================================================================================
	
	(*Check if absolute limit reached*)
	#b_AbsLim := (#IOdi_cntSec >= 108000000);
	
	(*increase counter when active and absolute limit not reached*)
	IF (#Ib_On AND #Ib_Pls1S AND NOT #b_AbsLim AND NOT #b_PulsFla) THEN
	    #IOdi_cntSec := #IOdi_cntSec + 1;
	    #IOdi_ResultHours := DINT_TO_INT(#IOdi_cntSec / 3600);
	    #i_modulo := DINT_TO_INT(#IOdi_cntSec MOD 3600);
	    #IOdi_ResultMin := #i_modulo / 60;
	    #IOdi_ResultSec := #i_modulo MOD 60;
	END_IF;
	
	(*Reset counters*)
	IF #Ib_Reset THEN
	    #IOdi_cntSec := 0;
	    #IOdi_ResultHours := 0;
	    #IOdi_ResultMin := 0;
	    #IOdi_ResultSec := 0;
	END_IF;
	
	(*set output if limit reached*)
	#Ob_LimitH := ((#IOdi_ResultHours >= #Ii_LimitH) AND (#Ii_LimitH > 0));
	#Ob_AbsLim := #b_AbsLim;
	
	#b_PulsFla := #Ib_Pls1S;
	
END_FUNCTION_BLOCK

FUNCTION "FC_UTIL_Interlock" : Void
TITLE = Bool to Byte
{ S7_Optimized_Access := 'FALSE' }
AUTHOR : Reditech
FAMILY : Utility
VERSION : 0.0
//Reditech standard utility block for a boolean conversion to byte
   VAR_INPUT 
      Ib_In1 : Bool;
      Ib_In2 : Bool;
      Ib_In3 : Bool;
      Ib_In4 : Bool;
      Ib_In5 : Bool;
   END_VAR

   VAR_OUTPUT 
      Oby_Out : Byte;
   END_VAR

   VAR_TEMP 
      by_out : Byte;
   END_VAR


BEGIN
	// ======================================================================================================================  
	// Purpose: Reditech standard utility block for a boolean conversion to byte
	// ----------------------------------------------------------------------------------------------------------------------
	// Date (dd MMM yyyy)   Developer                                   Version Comments/Reason for change
	// ..................   .........                                   ....... ..........................
	// 30 OCT 2019         Ivan Galhardoni                              01      Initial (creation)
	// 
	// ======================================================================================================================
	
	#by_out := 0;
	IF #Ib_In1 THEN
	  #by_out := #by_out OR 16#1;
	END_IF;
	IF #Ib_In2 THEN
	  #by_out := #by_out OR 16#2;
	END_IF;
	IF #Ib_In3 THEN
	  #by_out := #by_out OR 16#4;
	END_IF;
	IF #Ib_In4 THEN
	  #by_out := #by_out OR 16#8;
	END_IF;
	IF #Ib_In5 THEN
	  #by_out := #by_out OR 16#10;
	END_IF;
	
	#Oby_Out := #by_out;
	
	
END_FUNCTION

FUNCTION "FC_UTIL_AlmAck" : Void
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
   VAR_INPUT 
      Ib_CmdAck : Bool;
   END_VAR

   VAR_OUTPUT 
      Oi_StaAlm : Int;
      Ob_StaAlm : Bool;
      Ob_StaNewAlm : Bool;
   END_VAR

   VAR_IN_OUT 
      IO_Alm0 : Bool;
      IO_Alm1 : Bool;
      IO_Alm2 : Bool;
      IO_Alm3 : Bool;
      IO_Alm4 : Bool;
      IO_Alm5 : Bool;
      IO_Alm6 : Bool;
      IO_Alm7 : Bool;
      IO_Alm8 : Bool;
      IO_Alm9 : Bool;
      IO_Alm10 : Bool;
      IO_Alm11 : Bool;
      IO_Alm12 : Bool;
      IO_Alm13 : Bool;
      IO_Alm14 : Bool;
      IO_Alm15 : Bool;
      IOi_StaAck : Int;
   END_VAR

   VAR_TEMP 
      i_Temp : Int;
   END_VAR


BEGIN
	// =============================================================================================================================  
	// Purpose: Reditech standard function for alarmhandling
	// -----------------------------------------------------------------------------------------------------------------------------
	// Date (dd MMM yyyy)   Developer                                   Version Comments/Reason for change
	// ..................   .........                                   ....... ..........................
	// 20 Dec 2018          Bram Verheyen                               01.0    Initial (creation)
	
	//============================================================================================
	// Copy all alarms to integer
	//============================================================================================
	#Oi_StaAlm.%X0 := #IO_Alm0;
	#Oi_StaAlm.%X1 := #IO_Alm1;
	#Oi_StaAlm.%X2 := #IO_Alm2;
	#Oi_StaAlm.%X3 := #IO_Alm3;
	#Oi_StaAlm.%X4 := #IO_Alm4;
	#Oi_StaAlm.%X5 := #IO_Alm5;
	#Oi_StaAlm.%X6 := #IO_Alm6;
	#Oi_StaAlm.%X7 := #IO_Alm7;
	#Oi_StaAlm.%X8 := #IO_Alm8;
	#Oi_StaAlm.%X9 := #IO_Alm9;
	#Oi_StaAlm.%X10 := #IO_Alm10;
	#Oi_StaAlm.%X11 := #IO_Alm11;
	#Oi_StaAlm.%X12 := #IO_Alm12;
	#Oi_StaAlm.%X13 := #IO_Alm13;
	#Oi_StaAlm.%X14 := #IO_Alm14;
	#Oi_StaAlm.%X15 := #IO_Alm15;
	
	//============================================================================================    
	// Set acknowledge for all alarms --> Alarm reset from popup or area
	//============================================================================================
	IF #Ib_CmdAck THEN
	    #IOi_StaAck := #Oi_StaAlm;
	END_IF;
	
	//============================================================================================    
	// Reset acknowledge for all alarms --> for alarms that have been solved
	//============================================================================================
	#IOi_StaAck := WORD_TO_INT(INT_TO_WORD(#IOi_StaAck) AND INT_TO_WORD(#Oi_StaAlm));
	
	//============================================================================================    
	// Reset alarms --> for all acknowledged alarms
	//============================================================================================ 
	#IO_Alm0 := #IO_Alm0 AND NOT #Ib_CmdAck;
	#IO_Alm1 := #IO_Alm1 AND NOT #Ib_CmdAck;
	#IO_Alm2 := #IO_Alm2 AND NOT #Ib_CmdAck;
	#IO_Alm3 := #IO_Alm3 AND NOT #Ib_CmdAck;
	#IO_Alm4 := #IO_Alm4 AND NOT #Ib_CmdAck;
	#IO_Alm5 := #IO_Alm5 AND NOT #Ib_CmdAck;
	#IO_Alm6 := #IO_Alm6 AND NOT #Ib_CmdAck;
	#IO_Alm7 := #IO_Alm7 AND NOT #Ib_CmdAck;
	#IO_Alm8 := #IO_Alm8 AND NOT #Ib_CmdAck;
	#IO_Alm9 := #IO_Alm9 AND NOT #Ib_CmdAck;
	#IO_Alm10 := #IO_Alm10 AND NOT #Ib_CmdAck;
	#IO_Alm11 := #IO_Alm11 AND NOT #Ib_CmdAck;
	#IO_Alm12 := #IO_Alm12 AND NOT #Ib_CmdAck;
	#IO_Alm13 := #IO_Alm13 AND NOT #Ib_CmdAck;
	#IO_Alm14 := #IO_Alm14 AND NOT #Ib_CmdAck;
	#IO_Alm15 := #IO_Alm15 AND NOT #Ib_CmdAck;
	
	//============================================================================================    
	// Status: Alarm present an new (unacknowledged) alarm
	//============================================================================================
	#i_Temp := WORD_TO_INT(INT_TO_WORD(#Oi_StaAlm) AND NOT INT_TO_WORD(#IOi_StaAck));
	#Ob_StaNewAlm := #i_Temp > 0;
	#Ob_StaAlm := #IOi_StaAck > 0;
END_FUNCTION

FUNCTION_BLOCK "FB_CM_AV"
TITLE = Analog value
{ S7_Optimized_Access := 'FALSE' }
AUTHOR : Reditech
FAMILY : Typical
VERSION : 0.0
//Reditech standard typical for controlling an analog value
   VAR_INPUT 
      Iw_RawPw : Word;   //  RAW input from analogue input module
      Ir_ProcVal : Real;   //  input value from process
      Ir_ParRawMax : Real := 27648.0;   //  maximum for input value
      Ir_ParRawMin : Real;   //  minimum for input value
      Ir_ParRawHwfPerc : Real := 5.0;   //  percentage of input range for hardware failure detection
      Ir_ParScMax : Real := 100.0;   //  maximum for output (scaled) value
      Ir_ParScMin : Real;   //  minimum for output (scaled) value
      Ir_ParPulseLoad : Real;   //  Load of volume pulse in m³/h
      Ib_EnAlmHMax : Bool;   //  enable alarm high max
      Ib_EnAlmHH : Bool := 1;   //  enable alarm high
      Ib_EnWrnH : Bool := 1;   //  enable warning high
      Ib_EnWrnL : Bool := 1;   //  enable warning low
      Ib_EnAlmLL : Bool := 1;   //  enable alarm low
      Ib_EnAlmLMin : Bool;   //  enable alarm low min
      Ib_DevFlt : Bool;   //  device fault (external error)
      Ib_DisAlmWrn : Bool;   //  disable all alarms / warnings
      Ib_ExtPulse : Bool;   //  Volume pulse
      Iw_Cfg : Word := 16#0000;   //  .0=input from process / .=enable scaling of process input
   END_VAR

   VAR_OUTPUT 
      Or_ProcVal : Real := 0.0;   //  Process value (out)
      Or_VolTot : Real;   //  Total volume in m³
      Or_VolRst : Real;   //  Volume from last reset in m³
      Ob_Alm : Bool;   //  general alarm
      Ob_Wrn : Bool;   //  general warning
      Ob_AlmDevFlt : Bool;   //  alarm device fault
      Ob_LvlHMax : Bool;   //  level reached alarm high max
      Ob_LvlHH : Bool;   //  level reached alarm high
      Ob_LvlH : Bool;   //  level reached warning high
      Ob_LvlL : Bool;   //  level reached warning low
      Ob_LvlLL : Bool;   //  level reached alarm low
      Ob_LvlLMin : Bool;   //  level reached alarm low min
      Ob_AlmHMax : Bool;   //  alarm high max
      Ob_AlmHH : Bool;   //  alarm high
      Ob_WrnH : Bool;   //  warning high
      Ob_WrnL : Bool;   //  warning low
      Ob_AlmLL : Bool;   //  alarm low
      Ob_AlmLMin : Bool;   //  alarm low min
      Ob_SavPar : Bool;   //  Save parameter values to DB
      Odi_HmiSta : DInt;   //  State bits for HMI
      Odi_HmiStaInd : DInt;
      Odi_HmiAlm : DInt;   //  Alarm bit for HMI
      Oi_HmiAlm : Int;   //  Alarm bit for HMI
   END_VAR

   VAR_IN_OUT 
      IOr_SimVal : Real;   //  simulation value
      IOdi_HmiCmd : DInt;   //  Command bits from HMI
      IO_AreaCmd : "UDT_AreaCmd";   //  Command bits from area
      IO_AreaFb : "UDT_AreaFb";   //  Feedback bits to area
   END_VAR

   VAR 
      UDT_AlmHMax : "UDT_Lvl";
      UDT_AlmHH : "UDT_Lvl";
      UDT_WrnH : "UDT_Lvl";
      UDT_WrnL : "UDT_Lvl";
      UDT_AlmLL : "UDT_Lvl";
      UDT_AlmLMin : "UDT_Lvl";
      b_HmiCmdModSim { ExternalVisible := 'False'} : Bool;   //  command (toggle) simulation mode
      b_HmiCmdModDis { ExternalVisible := 'False'} : Bool;   //  command disable mode
      b_HmiCmdRst { ExternalVisible := 'False'} : Bool;   //  reset alarms
      b_HmiCmdRstTot : Bool;   //  reset totalizer
      b_HmiCmdSavParEng : Bool;   //  Save parameters to DB as engineer
      b_HmiCmdSavParMain : Bool;   //  Save parameters to DB as maintenance
      b_LvlHH { ExternalVisible := 'False'} : Bool;   //  alarm level high-high reached (unconditional)
      b_LvlH { ExternalVisible := 'False'} : Bool;   //  warning level high reached (unconditional)
      b_LvlL { ExternalVisible := 'False'} : Bool;   //  warning level low reached (unconditional)
      b_LvlLL { ExternalVisible := 'False'} : Bool;   //  alarm level low-low reached (unconditional)
      b_StaSim { ExternalVisible := 'False'} : Bool;   //  simulation mode on
      b_StaModDis { ExternalVisible := 'False'} : Bool;   //  disable mode on
      b_LvlHMax { ExternalVisible := 'False'} : Bool;   //  alarm level high max reached  (unconditional)
      b_LvlLMin { ExternalVisible := 'False'} : Bool;   //  alarm level low min reached  (unconditional)
      b_Wrn { ExternalVisible := 'False'} : Bool;   //  warning
      b_AlmLvl { ExternalVisible := 'False'} : Bool;   //  alarm on level
      b_AlmHw { ExternalVisible := 'False'} : Bool;   //  hardware alarm
      b_CfgInpProc { ExternalVisible := 'False'} : Bool;   //  configuration : input from process, not from perifery
      b_CfgEnScaleProcV { ExternalVisible := 'False'} : Bool;   //  configuration : enable scaling of input process value
      b_CfgDigAftPoint0 { ExternalVisible := 'False'} : Bool;   //  visualization proces value has 0 digits after decimal point
      b_CfgDigAftPoint1 { ExternalVisible := 'False'} : Bool;   //  visualization proces value has 1 digit after decimal point
      b_CfgDigAftPoint2 { ExternalVisible := 'False'} : Bool;   //  visualization proces value has 2 digits after decimal point
      b_CfgDigAftPoint3 { ExternalVisible := 'False'} : Bool;   //  visualization proces value has 3 digits after decimal point
      b_CfgDigAftPoint4 { ExternalVisible := 'False'} : Bool;   //  visualization proces value has 4 digits after decimal point
      b_CfgDisSim { ExternalVisible := 'False'} : Bool;
      b_CfgStopArea { ExternalVisible := 'False'} : Bool;
      b_CfgEnTotalizer { ExternalVisible := 'False'} : Bool;   //  Totalizer enabled
      b_CfgEnExtPulse { ExternalVisible := 'False'} : Bool;   //  external pulse available
      b_StaAreaMode { ExternalVisible := 'False'} : Bool;
      b_AlmHH { ExternalVisible := 'False'} : Bool;   //  alarm high high (if enabled)
      b_WrnH { ExternalVisible := 'False'} : Bool;   //  warning high (if enabled)
      b_WrnL { ExternalVisible := 'False'} : Bool;   //  warning low (if enabled)
      b_AlmLL { ExternalVisible := 'False'} : Bool;   //  alarm low-low (if enabled)
      b_AlmHwfHgh { ExternalVisible := 'False'} : Bool;   //  alarm hardware failure (input too high)
      b_AlmHwfLow { ExternalVisible := 'False'} : Bool;   //  alarm hardware failure (input too low)
      b_AlmDevF { ExternalVisible := 'False'} : Bool;   //  alarm device failure
      b_AlmHMax { ExternalVisible := 'False'} : Bool;   //  alarm high max (if enabled)
      b_AlmLMin { ExternalVisible := 'False'} : Bool;   //  alarm low min (if enabled)
      FB_UTIL_LimGrt_HMax : "FB_UTIL_LimGrt";
      FB_UTIL_LimGrt_HH : "FB_UTIL_LimGrt";
      FB_UTIL_LimGrt_H : "FB_UTIL_LimGrt";
      FB_UTIL_LimLes_L : "FB_UTIL_LimLes";
      FB_UTIL_LimLes_LL : "FB_UTIL_LimLes";
      FB_UTIL_LimLes_LMin : "FB_UTIL_LimLes";
      FB_UTIL_Totalizer : "FB_UTIL_Totalizer";
      b_dummy : Bool;
      i_dummy : Int;
      b_StaAlmNew : Bool;
      b_NoAlm : Bool;
      i_AlmAck : Int;
      b_RstAlm : Bool;
      b_StaAlm : Bool;
      R_CorrectionFactor : Real;
      b_CfgDisAlmHwf : Bool;
      b_CfgSetAlmHHStd : Bool;   // Set Alarm HH as Standard
      b_CfgSetAlmHStd : Bool;   // Set Alarm H as Standard
      b_CfgSetAlmLStd : Bool;   // Set Alarm L as Standard
      b_CfgSetAlmLLStd : Bool;   // Set Alarm LL as Standard
      i_Category : Int := 1;   // Set Eqp category value
   END_VAR

   VAR_TEMP 
      b_DisAlmWrn : Bool;   //  Disable all alarms/warnings
      r_RawPw : Real;   //  input word converted to real
      r_Value : Real;   //  input value
      r_ValueSelected : Real;   //  selected input value (raw or real)
      r_ValHwMax : Real;   //  trigger IOPplus
      r_ValHwMin : Real;   //  trigger IOPmin
      r_ValHwPerc : Real;   //  scaled difference max/min limit <-> IOP alarm
   END_VAR


BEGIN
	// =========================================================================================================================  
	// Purpose: Reditech standard typical for controlling an analog value
	// -------------------------------------------------------------------------------------------------------------------------
	// Date (dd MMM yyyy)   Developer                                   Version Comments/Reason for change
	// ..................   .........                                   ....... ..........................
	// 13 Nov 2018          Ivan Galhardoni                             09      Full review
	// 05 Jun 2023          Caio Ribeiro                                10      Changes to work with basic panels 
	// =========================================================================================================================
	
	//============================================================================================
	#b_CfgInpProc := #Iw_Cfg.%X0;
	#b_CfgEnScaleProcV := #Iw_Cfg.%X1;
	#b_CfgDigAftPoint0 := #Iw_Cfg.%X2;
	#b_CfgDigAftPoint1 := #Iw_Cfg.%X3;
	#b_CfgDigAftPoint2 := #Iw_Cfg.%X4;
	#b_CfgDigAftPoint3 := #Iw_Cfg.%X5;
	#b_CfgDigAftPoint4 := #Iw_Cfg.%X6;
	#b_CfgDisSim := #Iw_Cfg.%X10;
	#b_CfgStopArea := #Iw_Cfg.%X11;
	#b_CfgEnTotalizer := #Iw_Cfg.%X12;
	#b_CfgEnExtPulse := #Iw_Cfg.%X13;
	#b_CfgDisAlmHwf := #Iw_Cfg.%X14;
	
	//============================================================================================
	#b_DisAlmWrn := #Ib_DisAlmWrn OR #IO_AreaCmd.Alm.Dis OR #b_StaModDis;
	
	//============================================================================================
	#b_HmiCmdModSim := #IOdi_HmiCmd.%X0;
	#b_HmiCmdRst := #IOdi_HmiCmd.%X1;
	//#b_HmiCmdRstTot     := #IOdi_HmiCmd.%X2;    //caio ribeiro 10/05/22 - removi para resetar diretamente por botão na ihm o totalizador
	#b_HmiCmdSavParEng := #IOdi_HmiCmd.%X3;
	#b_HmiCmdSavParMain := #IOdi_HmiCmd.%X4;
	#b_HmiCmdModDis := #IOdi_HmiCmd.%X5;
	#IOdi_HmiCmd := 0;
	
	//============================================================================================
	IF #IO_AreaCmd.Sim.ForceOn
	    OR (#b_HmiCmdModSim AND NOT #b_StaSim AND NOT #IO_AreaCmd.Sim.ForceOff AND NOT #b_CfgDisSim) THEN
	    #b_StaSim := true;
	    #b_HmiCmdModSim := false; // reset of command necessary
	END_IF;
	IF #IO_AreaCmd.Sim.ForceOff
	    OR (#b_HmiCmdModSim AND #b_StaSim AND NOT #IO_AreaCmd.Sim.ForceOn)
	    OR #b_CfgDisSim THEN
	    #b_StaSim := false;
	    #b_HmiCmdModSim := false; // reset of command necessary
	END_IF;
	
	//============================================================================================
	IF (#b_HmiCmdModDis AND NOT #b_StaModDis) THEN // OR (#IO_AreaCmd.Mode.AreaMode AND #IO_AreaCmd.Mode.Dis) THEN // When area is disabled, alarm should not be supressed
	    #b_StaModDis := true;
	    #b_HmiCmdModDis := false;
	END_IF;
	IF (#b_HmiCmdModDis AND #b_StaModDis) OR (#IO_AreaCmd.Mode.AreaMode AND NOT #IO_AreaCmd.Mode.Dis) THEN
	    #b_StaModDis := false;
	    #b_HmiCmdModDis := false;
	END_IF;
	
	//============================================================================================
	
	IF NOT #b_StaSim THEN
	    IF #b_CfgInpProc THEN                   // select which input should be used (real or word)
	        #r_ValueSelected := #Ir_ProcVal;    // input from real       
	    ELSE
	        #r_ValueSelected := INT_TO_REAL(IN := WORD_TO_INT(IN := #Iw_RawPw));    // input from word (+convert to real)
	    END_IF;
	    
	    IF (#b_CfgInpProc AND NOT #b_CfgEnScaleProcV) THEN     // check if value should be scaled
	        #r_Value := #Ir_ProcVal;
	    ELSE
	        IF ((#Ir_ParRawMax - #Ir_ParRawMin) > 0) THEN // first check range to avoid division by 0
	            #r_Value := ((((#r_ValueSelected - #Ir_ParRawMin) / (#Ir_ParRawMax - #Ir_ParRawMin)) * (#Ir_ParScMax - #Ir_ParScMin)) + #Ir_ParScMin);
	        ELSE
	            #r_Value := #r_ValueSelected;
	        END_IF;
	    END_IF;
	    #IOr_SimVal := #r_Value;
	ELSE
	    #r_Value := #IOr_SimVal;
	END_IF;
	
	//============================================================================================
	IF #UDT_AlmHMax.ParSp > #Ir_ParScMax THEN
	    #UDT_AlmHMax.ParSp := #Ir_ParScMax;
	END_IF;
	IF #UDT_AlmHH.ParSp > #Ir_ParScMax THEN
	    #UDT_AlmHH.ParSp := #Ir_ParScMax;
	END_IF;
	IF #UDT_WrnH.ParSp > #Ir_ParScMax THEN
	    #UDT_WrnH.ParSp := #Ir_ParScMax;
	END_IF;
	IF #UDT_WrnL.ParSp < #Ir_ParScMin THEN
	    #UDT_WrnL.ParSp := #Ir_ParScMin;
	END_IF;
	IF #UDT_AlmLL.ParSp < #Ir_ParScMin THEN
	    #UDT_AlmLL.ParSp := #Ir_ParScMin;
	END_IF;
	IF #UDT_AlmLMin.ParSp < #Ir_ParScMin THEN
	    #UDT_AlmLMin.ParSp := #Ir_ParScMin;
	END_IF;
	
	//============================================================================================
	#b_NoAlm := false;
	#b_RstAlm := #b_HmiCmdRst OR #IO_AreaCmd.Alm.Rst;
	"FC_UTIL_AlmAck"(Ib_CmdAck := #b_RstAlm,
	                 Oi_StaAlm => #i_dummy,
	                 Ob_StaAlm => #b_dummy,
	                 Ob_StaNewAlm => #b_StaAlmNew,
	                 IO_Alm0 := #b_AlmHwfHgh,
	                 IO_Alm1 := #b_AlmHwfLow,
	                 IO_Alm2 := #b_AlmDevF,
	                 IO_Alm3 := #b_AlmHMax,
	                 IO_Alm4 := #b_AlmHH,
	                 IO_Alm5 := #b_WrnH,
	                 IO_Alm6 := #b_WrnL,
	                 IO_Alm7 := #b_AlmLL,
	                 IO_Alm8 := #b_AlmLMin,
	                 IO_Alm9 := #b_NoAlm,
	                 IO_Alm10 := #b_NoAlm,
	                 IO_Alm11 := #b_NoAlm,
	                 IO_Alm12 := #b_NoAlm,
	                 IO_Alm13 := #b_NoAlm,
	                 IO_Alm14 := #b_NoAlm,
	                 IO_Alm15 := #b_NoAlm,
	                 IOi_StaAck := #i_AlmAck);
	
	//============================================================================================
	
	#r_ValHwPerc := ((#Ir_ParScMax - #Ir_ParScMin) * #Ir_ParRawHwfPerc) / 100.0;
	#r_ValHwMax := #Ir_ParScMax + #r_ValHwPerc;
	#r_ValHwMin := #Ir_ParScMin - #r_ValHwPerc;
	
	IF (#r_Value > #r_ValHwMax) AND NOT #b_DisAlmWrn AND NOT #b_CfgDisAlmHwf THEN
	    #r_Value := #r_ValHwMax;
	    #b_AlmHwfHgh := true;
	END_IF;
	
	IF (#r_Value < #r_ValHwMin) AND NOT #b_DisAlmWrn THEN
	    #r_Value := #r_ValHwMin;
	    #b_AlmHwfLow := true;
	END_IF;
	
	IF (#Ib_DevFlt) AND NOT #b_DisAlmWrn THEN
	    #b_AlmDevF := true;
	END_IF;
	
	
	//============================================================================================
	#FB_UTIL_LimGrt_HMax(Ir_ProcVal := #Or_ProcVal,
	                     Ii_ParOnDel := #UDT_AlmHMax.ParOnDel,
	                     Ir_ParHys := #UDT_AlmHMax.ParHys,
	                     Ir_ParSp := #UDT_AlmHMax.ParSp,
	                     Ib_DisAlm := #b_DisAlmWrn OR NOT #Ib_EnAlmHMax,
	                     Ib_Rst := #b_RstAlm,
	                     Ob_Lvl => #b_LvlHMax,
	                     Ob_AlmWrn => #b_AlmHMax,
	                     IOi_OnDelAct := #UDT_AlmHMax.OnDelAct);
	IF NOT #UDT_AlmHMax.ParCfg THEN
	    #b_LvlHMax := false;
	    #b_AlmHMax := false;
	END_IF;
	
	//============================================================================================
	#FB_UTIL_LimGrt_HH(Ir_ProcVal := #Or_ProcVal,
	                   Ii_ParOnDel := #UDT_AlmHH.ParOnDel,
	                   Ir_ParHys := #UDT_AlmHH.ParHys,
	                   Ir_ParSp := #UDT_AlmHH.ParSp,
	                   Ib_DisAlm := #b_DisAlmWrn OR NOT #Ib_EnAlmHH,
	                   Ib_Rst := #b_RstAlm,
	                   Ob_Lvl => #b_LvlHH,
	                   Ob_AlmWrn => #b_AlmHH,
	                   IOi_OnDelAct := #UDT_AlmHH.OnDelAct);
	IF NOT #UDT_AlmHH.ParCfg THEN
	    #b_LvlHH := false;
	    #b_AlmHH := false;
	END_IF;
	
	//============================================================================================
	#FB_UTIL_LimGrt_H(Ir_ProcVal := #Or_ProcVal,
	                  Ii_ParOnDel := #UDT_WrnH.ParOnDel,
	                  Ir_ParHys := #UDT_WrnH.ParHys,
	                  Ir_ParSp := #UDT_WrnH.ParSp,
	                  Ib_DisAlm := #b_DisAlmWrn OR NOT #Ib_EnWrnH,
	                  Ib_Rst := #b_RstAlm,
	                  Ob_Lvl => #b_LvlH,
	                  Ob_AlmWrn => #b_WrnH,
	                  IOi_OnDelAct := #UDT_WrnH.OnDelAct);
	IF NOT #UDT_WrnH.ParCfg THEN
	    #b_LvlH := false;
	    #b_WrnH := false;
	END_IF;
	
	//============================================================================================
	#FB_UTIL_LimLes_L(Ir_ProcVal := #Or_ProcVal,
	                  Ii_ParOnDel := #UDT_WrnL.ParOnDel,
	                  Ir_ParHys := #UDT_WrnL.ParHys,
	                  Ir_ParSp := #UDT_WrnL.ParSp,
	                  Ib_DisAlm := #b_DisAlmWrn OR NOT #Ib_EnWrnL,
	                  Ib_Rst := #b_RstAlm,
	                  Ob_Lvl => #b_LvlL,
	                  Ob_AlmWrn => #b_WrnL,
	                  IOi_OnDelAct := #UDT_WrnL.OnDelAct);
	IF NOT #UDT_WrnL.ParCfg THEN
	    #b_LvlL := false;
	    #b_WrnL := false;
	END_IF;
	
	//============================================================================================
	#FB_UTIL_LimLes_LL(Ir_ProcVal := #Or_ProcVal,
	                   Ii_ParOnDel := #UDT_AlmLL.ParOnDel,
	                   Ir_ParHys := #UDT_AlmLL.ParHys,
	                   Ir_ParSp := #UDT_AlmLL.ParSp,
	                   Ib_DisAlm := #b_DisAlmWrn OR NOT #Ib_EnAlmLL,
	                   Ib_Rst := #b_RstAlm,
	                   Ob_Lvl => #b_LvlLL,
	                   Ob_AlmWrn => #b_AlmLL,
	                   IOi_OnDelAct := #UDT_AlmLL.OnDelAct);
	IF NOT #UDT_AlmLL.ParCfg THEN
	    #b_LvlLL := false;
	    #b_AlmLL := false;
	END_IF;
	
	//============================================================================================
	#FB_UTIL_LimLes_LMin(Ir_ProcVal := #Or_ProcVal,
	                     Ii_ParOnDel := #UDT_AlmLMin.ParOnDel,
	                     Ir_ParHys := #UDT_AlmLMin.ParHys,
	                     Ir_ParSp := #UDT_AlmLMin.ParSp,
	                     Ib_DisAlm := #b_DisAlmWrn OR NOT #Ib_EnAlmLMin,
	                     Ib_Rst := #b_RstAlm,
	                     Ob_Lvl => #b_LvlLMin,
	                     Ob_AlmWrn => #b_AlmLMin,
	                     IOi_OnDelAct := #UDT_AlmLMin.OnDelAct);
	IF NOT #UDT_AlmLMin.ParCfg THEN
	    #b_LvlLMin := false;
	    #b_AlmLMin := false;
	END_IF;
	
	//============================================================================================
	#b_AlmHw := (#b_AlmDevF OR #b_AlmHwfHgh OR #b_AlmHwfLow);
	#b_AlmLvl := (#b_AlmHMax OR #b_AlmHH OR #b_AlmLL OR #b_AlmLMin);
	#b_StaAlm := (#b_AlmHw OR #b_AlmLvl);
	
	#Ob_AlmDevFlt := #b_AlmHw;
	#Ob_AlmHMax := #b_AlmHMax;
	#Ob_AlmHH := #b_AlmHH;
	#Ob_WrnH := #b_WrnH;
	#Ob_WrnL := #b_WrnL;
	#Ob_AlmLL := #b_AlmLL;
	#Ob_AlmLMin := #b_AlmLMin;
	#Ob_Alm := #b_StaAlm;
	
	//============================================================================================
	#b_Wrn := (#b_WrnH OR #b_WrnL);
	#Ob_Wrn := #b_Wrn;
	
	//============================================================================================
	#Ob_LvlHMax := #b_LvlHMax;
	#Ob_LvlHH := #b_LvlHH;
	#Ob_LvlH := #b_LvlH;
	#Ob_LvlL := #b_LvlL;
	#Ob_LvlLL := #b_LvlLL;
	#Ob_LvlLMin := #b_LvlLMin;
	#Or_ProcVal := #r_Value;
	
	//============================================================================================
	
	IF #b_CfgEnTotalizer THEN
	    #FB_UTIL_Totalizer(Ir_ProcValFlow := #Or_ProcVal,
	                       Ib_1sPulse := "Clock_1Hz",
	                       Ib_RstVol := #b_HmiCmdRstTot,
	                       Or_VolTot => #Or_VolTot,
	                       Or_VolRst => #Or_VolRst);
	END_IF;
	
	//============================================================================================
	#Odi_HmiSta := 0;
	#Odi_HmiSta.%X0 := #b_LvlHH;
	#Odi_HmiSta.%X1 := #b_LvlH;
	#Odi_HmiSta.%X2 := #b_LvlL;
	#Odi_HmiSta.%X3 := #b_LvlLL;
	#Odi_HmiSta.%X4 := #b_StaSim;
	#Odi_HmiSta.%X5 := #b_StaModDis;
	#Odi_HmiSta.%X6 := #b_LvlHMax;
	#Odi_HmiSta.%X7 := #b_LvlLMin;
	#Odi_HmiSta.%X10 := #b_CfgDigAftPoint0;
	#Odi_HmiSta.%X11 := #b_CfgDigAftPoint1;
	#Odi_HmiSta.%X12 := #b_CfgDigAftPoint2;
	#Odi_HmiSta.%X13 := #b_CfgDigAftPoint3;
	#Odi_HmiSta.%X14 := #b_CfgDigAftPoint4;
	#Odi_HmiSta.%X16 := #b_Wrn;
	#Odi_HmiSta.%X17 := #b_AlmLvl;
	#Odi_HmiSta.%X18 := #b_AlmHw;
	#Odi_HmiSta.%X24 := #b_CfgInpProc;
	#Odi_HmiSta.%X25 := #b_CfgEnScaleProcV;
	#Odi_HmiSta.%X28 := #IO_AreaCmd.Mode.AreaMode;
	
	//============================================================================================
	#Odi_HmiAlm := 0;
	#Odi_HmiAlm.%X0 := #b_AlmHH;
	#Odi_HmiAlm.%X1 := #b_WrnH;
	#Odi_HmiAlm.%X2 := #b_WrnL;
	#Odi_HmiAlm.%X3 := #b_AlmLL;
	#Odi_HmiAlm.%X4 := #b_AlmHwfHgh;
	#Odi_HmiAlm.%X5 := #b_AlmHwfLow;
	#Odi_HmiAlm.%X6 := #b_AlmDevF;
	#Odi_HmiAlm.%X7 := #b_AlmHMax;
	#Odi_HmiAlm.%X8 := #b_AlmLMin;
	#Oi_HmiAlm := DINT_TO_INT(#Odi_HmiAlm);
	
	//============================================================================================
	#Odi_HmiStaInd.%X0 := #b_AlmHH;
	#Odi_HmiStaInd.%X1 := #b_WrnH;
	#Odi_HmiStaInd.%X2 := #b_WrnL;
	#Odi_HmiStaInd.%X3 := #b_AlmLL;
	#Odi_HmiStaInd.%X4 := #b_StaSim;
	
	
	//============================================================================================
	IF #b_StaModDis THEN
	    #IO_AreaFb.Mode.Dis := TRUE;
	END_IF;
	IF #b_StaAlm THEN
	    #IO_AreaFb.Alm.Alm := TRUE;
	END_IF;
	IF #b_Wrn THEN
	    #IO_AreaFb.Alm.Wrn := TRUE;
	END_IF;
	IF #b_StaAlmNew THEN
	    #IO_AreaFb.Alm.New := TRUE;
	END_IF;
	IF #b_StaAlm AND #b_CfgStopArea THEN
	    #IO_AreaFb.Alm.StopArea := TRUE;
	END_IF;
	IF #b_StaSim THEN
	    #IO_AreaFb.Sim.Sim := TRUE;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_CM_DCM"
TITLE = Motor
{ S7_Optimized_Access := 'FALSE' }
AUTHOR : Reditech
FAMILY : Typical
VERSION : 0.0
//Reditech standard typical for controlling a double direction motor
   VAR_INPUT 
      Ib_AutFwd : Bool;   //  automatic command forward
      Ib_AutRev : Bool;   //  automatic command reversed
      Ib_FbFwd : Bool;   //  feedback forward
      Ib_FbRev : Bool;   //  feedback reversed
      Ib_Is : Bool;   //  Status Isolation switch (0=ok, 1=error)
      Ib_Mps : Bool;   //  Status motor protection switch (0=ok, 1=error)
      Ib_DevFlt : Bool;
      Ib_DrwTest : Bool;   // Feedback Drawer in Test Position
      Ib_CommFault : Bool;   // Driver communication fault
      Ib_FbRem : Bool;   // Feedback SRW01 in Remote Mode
      Ii_ParTFb : Int := 5;   //  time out value for feedback monitoring
      Ii_ParTToRun : Int := 0;   //  time out value for time out run
      Iby_Saf : Byte := 16#00;   //  8 safety bits : 1=error
      Iby_IlOn : Byte;   //  8 interlock bits : 1 prevents start
      Ib_DisAlmWrn : Bool;
      Iw_Cfg : Word := 16#0001;   //  configuration : .0=enable second direction
      Iw_InstCurr : Real;   // Read the Actual Current from SRW01
      Iw_ErrCod : Int;   // Read the actual error code from simocode
   END_VAR

   VAR_OUTPUT 
      Ob_Fwd : Bool;   //  control output forward
      Ob_Rev : Bool;   //  control output reversed
      Ob_Off : Bool := TRUE;   //  control output off
      Ob_Alm : Bool;   //  general alarm
      Ob_StaFwd : Bool;   //  Status forward running
      Ob_StaRev : Bool;   //  Status reverse running
      Ob_StaOff : Bool := TRUE;   //  Status Off (not running)
      Odi_HmiSta : DInt;   //  State bits for HMI
      Oi_HmiStaInd : Int;   //  State bits for HMI
      Odi_HmiAlm : DInt;   //  Alarm bit for HMI
      Odi_ActCouRst : DInt := 0;   //  Actuation counter from last reset
      Odi_ActCouTot : DInt := 0;   //  Total actuation counter
      Odi_RunTimRst : DInt;   //  Operating hours from last reset
      Odi_RunTimTot : DInt;   //  Total operating hours
      Oi_HmiAlm : Int;   //  Alarm bit for HMI
      Or_InstCurr : Real;   // Indicates the actual current from SRW01
      Oi_ErrCod : Int;   // Indicates the actual code error from SRW01
      Ob_Remote : Bool;   // Remote Operation: 0= Local Op; 1= Remote Op
   END_VAR

   VAR_IN_OUT 
      IOdi_HmiCmd : DInt;   //  Command bits from HMI
      IO_AreaCmd : "UDT_AreaCmd";   //  Command bits from area
      IO_AreaFb : "UDT_AreaFb";   //  Feedback bits to area
   END_VAR

   VAR 
      i_TmrToRun { ExternalVisible := 'False'} : Int;   //  timer time out  run control
      b_HmiCmdModAut { ExternalVisible := 'False'} : Bool;   //  command change mode to AUTO
      b_HmiCmdModMan { ExternalVisible := 'False'} : Bool;   //  command change mode to MANUAL
      b_HmiCmdModDis { ExternalVisible := 'False'} : Bool;   //  command change mode to DISABLED
      b_HmiCmdSim { ExternalVisible := 'False'} : Bool;   //  toggle simulation mode
      b_HmiCmdFwd { ExternalVisible := 'False'} : Bool;   //  command start forward
      b_HmiCmdRev { ExternalVisible := 'False'} : Bool;   //  command start reversed
      b_HmiCmdStp { ExternalVisible := 'False'} : Bool;   //  command stop
      b_HmiCmdRst { ExternalVisible := 'False'} : Bool;   //  reset alarms
      b_HmiCmdRstActOpe { ExternalVisible := 'False'} : Bool;   //  reset actuation counter and operating hours
      b_ManutLocal { ExternalVisible := 'False'} : Bool;   // command change mode to "Manut.Local"
      b_StaModAut { ExternalVisible := 'False'} : Bool;   //  state AUTOMATIC
      b_StaModMan { ExternalVisible := 'False'} : Bool := TRUE;   //  state MANUAL
      b_StaModDis { ExternalVisible := 'False'} : Bool;   //  state DISABLED
      b_StaSim { ExternalVisible := 'False'} : Bool;   //  state simulation ON
      b_StaIlOn { ExternalVisible := 'False'} : Bool;   //  state interlock ON : 1 = interlocked (prevents start)
      b_StaSaf { ExternalVisible := 'False'} : Bool;   //  state safety : 1 = error (stops the motor)
      b_ReqFwd { ExternalVisible := 'False'} : Bool;   //  output forward
      b_ReqRev { ExternalVisible := 'False'} : Bool;   //  output reversed
      b_StaAlm { ExternalVisible := 'False'} : Bool;   //  general alarm
      b_CfgEnRev { ExternalVisible := 'False'} : Bool;   //  configuration : reversed direction enabled
      b_CfgHldMod { ExternalVisible := 'False'} : Bool;   //  configuration on alarm: 1=hold active mode
      b_CfgPushToRun { ExternalVisible := 'False'} : Bool;
      b_CfgDisableSim { ExternalVisible := 'False'} : Bool;
      b_CfgStopArea { ExternalVisible := 'False'} : Bool;
      b_AlmToFb { ExternalVisible := 'False'} : Bool;   //  alarm time out feedback
      b_AlmToRun { ExternalVisible := 'False'} : Bool;   //  alarm run time too long
      b_AlmIs { ExternalVisible := 'False'} : Bool;   //  alarm isolation switch
      b_AlmMps { ExternalVisible := 'False'} : Bool;   //  alarm motor protection switch
      b_AlmDevFlt { ExternalVisible := 'False'} : Bool;   //  alarm device fault
      b_ReqAut { ExternalVisible := 'False'} : Bool;   //  automatic mode requested
      b_ReqMan { ExternalVisible := 'False'} : Bool;   //  manual mode requested
      b_ReqDis { ExternalVisible := 'False'} : Bool;   //  disabled mode requested
      b_CmdManFwd { ExternalVisible := 'False'} : Bool;   //  internal memo : manual command forward
      b_CmdManRev { ExternalVisible := 'False'} : Bool;   //  internal memo : manual command reversed
      b_CmdAutFwd { ExternalVisible := 'False'} : Bool;   //  internal memo : automatic command forward
      b_CmdAutRev { ExternalVisible := 'False'} : Bool;   //  internal memo : automatic command reversed
      b_CmdFwd { ExternalVisible := 'False'} : Bool;   //  internal memo : command forward (combined manual and auto)
      b_CmdRev { ExternalVisible := 'False'} : Bool;   //  internal memo : command reversed(combined manual and auto)
      b_FbErrFwd { ExternalVisible := 'False'} : Bool;   //  internal memo : error detection no feedback after start
      b_FbErrRev { ExternalVisible := 'False'} : Bool;   //  internal memo : error detection feedback still active after stop
      b_TFbFwdOut { ExternalVisible := 'False'} : Bool;   //  timer finished for feedback monitoring run (Fwd OR Rev)
      b_TFPRevOut { ExternalVisible := 'False'} : Bool;   //  timer finished for feedback monitoring stop
      b_TToRunOut { ExternalVisible := 'False'} : Bool;   //  timer finished for time out run
      i_TmrFbRev { ExternalVisible := 'False'} : Int;   //  timer feedback monitoring stop in milliseconds
      i_TmrFbFwd { ExternalVisible := 'False'} : Int;   //  timer feedback monitoring start in milliseconds
      FB_UTIL_TON_Del_1 { ExternalVisible := 'False'} : "FB_UTIL_TON_Sec";
      FB_UTIL_TON_Del_2 { ExternalVisible := 'False'} : "FB_UTIL_TON_Sec";
      FB_UTIL_TON_Del_3 { ExternalVisible := 'False'} : "FB_UTIL_TON_Sec";
      b_Old_Ob_Fwd : Bool;
      b_Old_Ob_Rev : Bool;
      FB_UTIL_Work_H_Rst : "FB_UTIL_Work_H";
      FB_UTIL_Work_H_Tot : "FB_UTIL_Work_H";
      b_FbSimFwd { ExternalVisible := 'False'} : Bool;   //  internal feedback simulation value opened
      b_FbSimRev { ExternalVisible := 'False'} : Bool;   //  internal feedback simulation value closed
      b_dummy : Bool;
      i_dummy : Int;
      b_StaAlmNew : Bool;
      b_NoAlm : Bool;
      i_AlmAck : Int;
      b_DisAlmWrn : Bool;
      b_RstAlm : Bool;
      w_InstCurr : Real;
      w_ErrCod : Int;
      b_DrwTest : Bool;
      b_CommFault : Bool;
      b_FbRem : Bool;
      b_RemoteM : Bool;
      b_PerRemMod : Bool;
      b_ErrorSWR : Bool;
      I_HmiSta : Word;
      i_Category : Int := 1;   // Device alarm category setting
      b_EnDisPump : Bool;   // Enable/Disable pump HMI
   END_VAR

   VAR_TEMP 
      di_AUX : DInt;   //  auxiliary double word for calculation of state or alarm word to HMI
   END_VAR


BEGIN
	// =========================================================================================================================  
	// Purpose: Reditech standard typical for controlling a double direction motor
	// -------------------------------------------------------------------------------------------------------------------------
	// Date (dd MMM yyyy)   Developer                                   Version Comments/Reason for change
	// ..................   .........                                   ....... ..........................
	// 12 Dec 2018          Bram Verheyen                               08.0    Full review
	// 30 Jan 2019          Matthias De Staelen                         08.1    Outputs can be high in simulation mode
	// 08 Apr 2020          Willian Barroso                             08.2    Full review
	// 03 Jul 2021          Ivan Galhardoni                             08.3    Was adopted right signal for communication fault
	// 30 Jul 2023          Caio Ribeiro                                08.4    Added info for hmi basic panel
	// =========================================================================================================================
	
	//============================================================================================
	#b_CfgEnRev := #Iw_Cfg.%X0;
	#b_CfgHldMod := #Iw_Cfg.%X1;
	#b_CfgPushToRun := #Iw_Cfg.%X8;
	#b_CfgDisableSim := #Iw_Cfg.%X10;
	#b_CfgStopArea := #Iw_Cfg.%X11;
	
	//============================================================================================
	#b_DisAlmWrn := #Ib_DisAlmWrn OR #IO_AreaCmd.Alm.Dis OR #b_StaModDis OR #b_StaSim;
	
	//============================================================================================
	#b_StaSaf := (#Iby_Saf <> 0) AND NOT #b_DisAlmWrn;
	#b_StaIlOn := (#Iby_IlOn <> 0);
	
	//============================================================================================
	#b_HmiCmdModAut := #IOdi_HmiCmd.%X0;
	#b_HmiCmdModMan := #IOdi_HmiCmd.%X1;
	#b_HmiCmdModDis := #IOdi_HmiCmd.%X2;
	#b_HmiCmdSim := #IOdi_HmiCmd.%X3;
	#b_HmiCmdFwd := #IOdi_HmiCmd.%X4;
	#b_HmiCmdRev := #IOdi_HmiCmd.%X5;
	#b_HmiCmdStp := #IOdi_HmiCmd.%X6;
	#b_HmiCmdRst := #IOdi_HmiCmd.%X7;
	#b_HmiCmdRstActOpe := #IOdi_HmiCmd.%X8;
	
	IF #b_CfgPushToRun THEN
	    #IOdi_HmiCmd := DWORD_TO_DINT(DINT_TO_DWORD(#IOdi_HmiCmd) AND 48);
	ELSE
	    #IOdi_HmiCmd := 0;
	END_IF;
	
	//============================================================================================
	IF #b_StaSim THEN
	    #w_ErrCod := 12;
	    #b_FbRem := TRUE;
	ELSE
	    #w_ErrCod := #Iw_ErrCod;
	    #b_FbRem := #Ib_FbRem;
	END_IF;
	
	#w_InstCurr := #Iw_InstCurr;
	#b_DrwTest := #Ib_DrwTest;
	
	//============================================================================================
	IF #IO_AreaCmd.Mode.AreaMode THEN
	    #b_ReqAut := #IO_AreaCmd.Mode.Auto;
	    #b_ReqMan := #IO_AreaCmd.Mode.Man;
	    #b_ReqDis := #IO_AreaCmd.Mode.Dis;
	ELSE
	    IF #b_CfgHldMod THEN
	        #b_ReqAut := #b_HmiCmdModAut;
	        #b_ReqMan := #b_HmiCmdModMan;
	        #b_ReqDis := #b_HmiCmdModDis;
	    ELSE
	        #b_ReqAut := #b_HmiCmdModAut AND NOT #b_StaAlm AND NOT #b_StaSaf;
	        #b_ReqMan := #b_HmiCmdModMan OR ((#b_StaAlm OR #b_StaSaf) AND NOT #b_StaModDis);
	        #b_ReqDis := #b_HmiCmdModDis;
	    END_IF;
	END_IF;
	
	IF (#b_ReqAut AND NOT #b_ReqMan AND NOT #b_ReqDis) THEN
	    #b_StaModAut := true;
	    #b_StaModMan := false;
	    #b_StaModDis := false;
	END_IF;
	IF (#b_ReqMan AND NOT #b_ReqAut AND NOT #b_ReqDis) THEN
	    #b_StaModAut := false;
	    #b_StaModMan := true;
	    #b_StaModDis := false;
	END_IF;
	IF (#b_ReqDis AND NOT #b_ReqAut AND NOT #b_ReqMan) THEN
	    #b_StaModAut := false;
	    #b_StaModMan := false;
	    #b_StaModDis := true;
	END_IF;
	
	//============================================================================================
	IF #IO_AreaCmd.Sim.ForceOn OR (#b_HmiCmdSim AND NOT #b_StaSim AND NOT #IO_AreaCmd.Sim.ForceOn AND NOT #IO_AreaCmd.Sim.ForceOff) THEN
	    #b_StaSim := true;
	    #b_HmiCmdSim := false; // reset of command necessary, else simulation will always be reset immediately by following instructions
	END_IF;
	IF #IO_AreaCmd.Sim.ForceOff OR (#b_HmiCmdSim AND #b_StaSim AND NOT #IO_AreaCmd.Sim.ForceOn AND NOT #IO_AreaCmd.Sim.ForceOff) THEN
	    #b_StaSim := false;
	    #b_HmiCmdSim := false;
	END_IF;
	
	//============================================================================================
	// reset simulated feedback when starting to move
	IF (#b_ReqFwd AND NOT #b_FbSimFwd)
	    OR (#b_ReqRev AND NOT #b_FbSimRev)
	    OR #b_HmiCmdStp
	    OR (NOT #b_ReqFwd AND NOT #b_ReqRev)
	    OR #b_StaIlOn
	    OR #b_StaAlm THEN
	    #b_FbSimFwd := false;
	    #b_FbSimRev := false;
	END_IF;
	// set simulated feedback after delay
	IF ((#i_TmrFbFwd <= 1) OR #Ii_ParTFb = 0) AND #b_ReqFwd THEN
	    #b_FbSimFwd := true;
	    #b_FbSimRev := false;
	END_IF;
	// set simulated feedback after delay
	IF ((#i_TmrFbRev <= 1) OR #Ii_ParTFb = 0) AND #b_ReqRev THEN
	    #b_FbSimFwd := false;
	    #b_FbSimRev := true;
	END_IF;
	
	//============================================================================================
	// feedback, selection simulation or real time
	#Ob_StaFwd := (NOT #b_StaSim AND #Ib_FbFwd)
	OR (#b_StaSim AND #b_FbSimFwd);
	
	#Ob_StaRev := (NOT #b_StaSim AND #Ib_FbRev)
	OR (#b_StaSim AND #b_FbSimRev);
	
	#Ob_StaOff := NOT #Ob_StaFwd AND NOT #Ob_StaRev;
	
	//============================================================================================
	#b_NoAlm := false;
	#b_RstAlm := #b_HmiCmdRst OR #IO_AreaCmd.Alm.Rst;
	"FC_UTIL_AlmAck"(Ib_CmdAck := #b_RstAlm,
	                 Oi_StaAlm => #i_dummy,
	                 Ob_StaAlm => #b_dummy,
	                 Ob_StaNewAlm => #b_StaAlmNew,
	                 IO_Alm0 := #b_AlmToFb,
	                 IO_Alm1 := #b_AlmToRun,
	                 IO_Alm2 := #b_AlmIs,
	                 IO_Alm3 := #b_AlmMps,
	                 IO_Alm4 := #b_AlmDevFlt,
	                 IO_Alm5 := #b_CommFault,
	                 IO_Alm6 := #b_ErrorSWR,
	                 IO_Alm7 := #b_NoAlm,
	                 IO_Alm8 := #b_NoAlm,
	                 IO_Alm9 := #b_NoAlm,
	                 IO_Alm10 := #b_NoAlm,
	                 IO_Alm11 := #b_NoAlm,
	                 IO_Alm12 := #b_NoAlm,
	                 IO_Alm13 := #b_NoAlm,
	                 IO_Alm14 := #b_NoAlm,
	                 IO_Alm15 := #b_NoAlm,
	                 IOi_StaAck := #i_AlmAck);
	
	//============================================================================================
	IF (#Ii_ParTFb > 0) THEN  // only when time value > 0
	    #FB_UTIL_TON_Del_1(Ii_tValue := #Ii_ParTFb,
	                       Ib_In := (#b_ReqFwd AND NOT #Ob_StaFwd),
	                       Ii_Base := 1,
	                       Ib_Hold := 0,
	                       Ob_Out => #b_FbErrFwd,
	                       Oi_tmrValue => #i_TmrFbFwd);
	END_IF;
	
	IF (#Ii_ParTFb > 0) THEN  // only when time value > 0
	    #FB_UTIL_TON_Del_2(Ii_tValue := #Ii_ParTFb,
	                       Ib_In := (#b_ReqRev AND NOT #Ob_StaRev),
	                       Ii_Base := 1,
	                       Ib_Hold := 0,
	                       Ob_Out => #b_FbErrRev,
	                       Oi_tmrValue => #i_TmrFbRev);
	END_IF;
	
	IF ((#b_FbErrFwd OR #b_FbErrRev) AND (#Ii_ParTFb > 0)) AND NOT #b_DisAlmWrn THEN
	    #b_AlmToFb := true;
	END_IF;
	
	//============================================================================================
	IF (#Ii_ParTToRun > 0) THEN
	    #FB_UTIL_TON_Del_3(Ii_tValue := #Ii_ParTToRun,
	                       Ib_In := (#b_ReqFwd OR #b_ReqRev),
	                       Ii_Base := 1,
	                       Ib_Hold := 0,
	                       Ob_Out => #b_TToRunOut,
	                       Oi_tmrValue => #i_TmrToRun);
	END_IF;
	
	IF (#b_TToRunOut AND (#Ii_ParTToRun > 0)) AND NOT #b_DisAlmWrn THEN
	    #b_AlmToRun := true;
	END_IF;
	
	//============================================================================================
	IF #Ib_Is AND NOT #b_DisAlmWrn THEN
	    #b_AlmIs := true;
	END_IF;
	
	//============================================================================================
	IF #Ib_Mps AND NOT #b_DisAlmWrn THEN
	    #b_AlmMps := true;
	END_IF;
	
	//============================================================================================
	IF #Ib_DevFlt AND NOT #b_DisAlmWrn THEN
	    #b_AlmDevFlt := true;
	END_IF;
	
	//============================================================================================
	IF NOT #Ib_CommFault AND NOT #b_DrwTest AND NOT #b_DisAlmWrn THEN
	    #b_CommFault := true;
	END_IF;
	
	//============================================================================================
	IF (#w_ErrCod <> 0) AND NOT #b_DisAlmWrn AND (#w_ErrCod < 150) AND #w_ErrCod <> 9 AND
	    #w_ErrCod <> 10 AND #w_ErrCod <> 30 AND #w_ErrCod <> 31 AND (#w_ErrCod < 51 OR #w_ErrCod > 60)
	    AND (#w_ErrCod <> 131)
	THEN
	    #b_ErrorSWR := true;
	END_IF;
	
	//============================================================================================
	#b_StaAlm := #b_ErrorSWR OR #b_CommFault OR #b_AlmToFb OR #b_AlmToRun OR #b_StaSaf OR
	#b_AlmIs OR #b_AlmMps OR #b_AlmDevFlt OR NOT #b_EnDisPump;
	#Ob_Alm := #b_StaAlm;
	
	//============================================================================================
	#b_CmdAutFwd := (#Ib_AutFwd AND NOT #Ib_AutRev AND NOT #Ob_Rev);
	#b_CmdAutRev := (#Ib_AutRev AND NOT #Ib_AutFwd AND NOT #Ob_Fwd) AND #b_CfgEnRev;
	
	IF #b_StaModAut THEN
	    #b_CmdManFwd := #b_CmdAutFwd;
	    #b_CmdManRev := #b_CmdAutRev;
	END_IF;
	
	//============================================================================================
	IF #b_StaModMan AND NOT #b_CfgPushToRun THEN
	    IF (#b_HmiCmdFwd AND NOT #Ob_Rev) THEN
	        #b_CmdManFwd := true;
	        #b_CmdManRev := false;
	    END_IF;
	    IF (#b_HmiCmdRev AND NOT #Ob_Fwd AND #b_CfgEnRev) THEN
	        #b_CmdManFwd := false;
	        #b_CmdManRev := true;
	    END_IF;
	    IF #b_HmiCmdStp OR #b_StaAlm OR #b_StaModDis OR #b_StaIlOn THEN
	        #b_CmdManFwd := false;
	        #b_CmdManRev := false;
	    END_IF;
	END_IF;
	
	// Push to run active
	IF #b_StaModMan AND #b_CfgPushToRun THEN
	    #b_CmdManFwd := #b_HmiCmdFwd AND NOT #Ob_Rev AND NOT #b_StaAlm AND NOT #b_StaModDis;
	    #b_CmdManRev := #b_HmiCmdRev AND NOT #Ob_Fwd AND NOT #b_StaAlm AND NOT #b_StaModDis AND #b_CfgEnRev;
	END_IF;
	
	IF #b_StaModDis OR NOT #b_StaModMan THEN
	    #b_CmdManFwd := false;
	    #b_CmdManRev := false;
	END_IF;
	
	//============================================================================================
	#b_CmdFwd := (#b_StaModAut AND #b_CmdAutFwd) OR (#b_StaModMan AND #b_CmdManFwd);
	#b_CmdRev := (#b_StaModAut AND #b_CmdAutRev) OR (#b_StaModMan AND #b_CmdManRev);
	
	//============================================================================================
	#b_ReqFwd := (#b_CmdFwd AND NOT #b_StaAlm AND NOT #b_StaIlOn AND NOT #b_StaModDis);
	#b_ReqRev := (#b_CmdRev AND NOT #b_StaAlm AND NOT #b_StaIlOn AND NOT #b_StaModDis);
	
	//============================================================================================
	IF #b_StaSim THEN
	    #Ob_Fwd := FALSE;
	    #Ob_Rev := FALSE;
	ELSE
	    #Ob_Fwd := #b_ReqFwd;
	    #Ob_Rev := #b_ReqRev;
	END_IF;
	#Ob_Off := NOT #b_ReqFwd AND NOT #b_ReqRev;
	
	//============================================================================================
	#Odi_HmiSta.%X0 := #b_StaModAut;
	#Odi_HmiSta.%X1 := #b_StaModMan;
	#Odi_HmiSta.%X2 := #b_StaModDis;
	#Odi_HmiSta.%X3 := #b_StaSim;
	#Odi_HmiSta.%X5 := #b_StaIlOn;
	#Odi_HmiSta.%X6 := #b_StaSaf AND NOT #b_CommFault;
	#Odi_HmiSta.%X7 := #b_DrwTest;
	#Odi_HmiSta.%X12 := #b_FbRem;
	#Odi_HmiSta.%X16 := #b_ReqFwd;
	#Odi_HmiSta.%X17 := #b_ReqRev;
	#Odi_HmiSta.%X18 := #Ob_StaFwd;
	#Odi_HmiSta.%X19 := #Ob_StaRev;
	#Odi_HmiSta.%X20 := #b_StaAlm;
	#Odi_HmiSta.%X22 := #b_AlmMps;
	#Odi_HmiSta.%X28 := #IO_AreaCmd.Mode.AreaMode;
	#Odi_HmiSta.%X29 := #b_PerRemMod;
	
	#Oi_HmiStaInd.%X0 := 0;
	#Oi_HmiStaInd.%X0 := #b_StaModAut;
	#Oi_HmiStaInd.%X1 := #b_StaModMan;
	#Oi_HmiStaInd.%X2 := #b_StaModDis;
	#Oi_HmiStaInd.%X3 := #b_StaSim;
	#Oi_HmiStaInd.%X4 := #b_StaAlm;
	#Oi_HmiStaInd.%X5 := #Ob_StaFwd AND NOT #b_StaAlm;
	#Oi_HmiStaInd.%X6 := NOT #b_ReqFwd AND NOT #b_ReqRev AND NOT #b_StaAlm;
	
	#I_HmiSta.%X0 := #b_StaModAut;
	#I_HmiSta.%X1 := #b_StaModMan;
	#I_HmiSta.%X2 := #b_StaModDis;
	#I_HmiSta.%X3 := #b_StaSim;
	#I_HmiSta.%X5 := #b_StaIlOn;
	#I_HmiSta.%X6 := #b_StaSaf AND NOT #b_CommFault;
	#I_HmiSta.%X7 := #b_DrwTest;
	#I_HmiSta.%X8 := #b_FbRem;
	#I_HmiSta.%X9 := #Ob_StaFwd;
	#I_HmiSta.%X10 := #b_StaAlm;
	#I_HmiSta.%X11 := #b_AlmMps;
	
	//============================================================================================
	#di_AUX := 0;
	#di_AUX.%X0 := #b_AlmToFb;
	#di_AUX.%X1 := #b_AlmToRun;
	#di_AUX.%X2 := #b_AlmIs;
	#di_AUX.%X3 := #b_AlmMps;
	#di_AUX.%X4 := #b_AlmDevFlt;
	#di_AUX.%X6 := #b_CommFault;
	#di_AUX.%X7 := #b_ErrorSWR;
	#di_AUX.%X16 := #Iby_IlOn.%X0;
	#di_AUX.%X17 := #Iby_IlOn.%X1;
	#di_AUX.%X18 := #Iby_IlOn.%X2;
	#di_AUX.%X19 := #Iby_IlOn.%X3;
	#di_AUX.%X20 := #Iby_IlOn.%X4;
	#di_AUX.%X21 := #Iby_IlOn.%X5;
	#di_AUX.%X22 := #Iby_IlOn.%X6;
	#di_AUX.%X23 := #Iby_IlOn.%X7;
	#di_AUX.%X24 := #Iby_Saf.%X0;
	#di_AUX.%X25 := #Iby_Saf.%X1;
	#di_AUX.%X26 := #Iby_Saf.%X2;
	#di_AUX.%X27 := #Iby_Saf.%X3;
	#di_AUX.%X28 := #Iby_Saf.%X4;
	#di_AUX.%X29 := #Iby_Saf.%X5;
	#di_AUX.%X30 := #Iby_Saf.%X6;
	#di_AUX.%X31 := #Iby_Saf.%X7;
	#Odi_HmiAlm := #di_AUX;
	
	//============================================================================================
	#di_AUX := 0;
	#di_AUX.%X0 := #b_AlmToFb;
	#di_AUX.%X1 := #b_AlmToRun;
	#di_AUX.%X2 := #b_AlmIs;
	#di_AUX.%X3 := #b_AlmMps;
	#di_AUX.%X4 := #b_AlmDevFlt OR #b_CommFault;
	#di_AUX.%X6 := #b_ErrorSWR;
	
	#Oi_HmiAlm := DINT_TO_INT(#di_AUX);
	
	//============================================================================================
	IF #b_StaModDis THEN
	    #IO_AreaFb.Mode.Dis := TRUE;
	END_IF;
	IF #b_StaModMan THEN
	    #IO_AreaFb.Mode.Man := TRUE;
	END_IF;
	IF #b_StaModAut THEN
	    #IO_AreaFb.Mode.Auto := TRUE;
	END_IF;
	IF #b_StaAlm THEN
	    #IO_AreaFb.Alm.Alm := TRUE;
	END_IF;
	IF #b_StaAlmNew THEN
	    #IO_AreaFb.Alm.New := TRUE;
	END_IF;
	IF #b_StaSim THEN
	    #IO_AreaFb.Sim.Sim := TRUE;
	END_IF;
	IF #b_StaAlm AND #b_CfgStopArea THEN
	    #IO_AreaFb.Alm.StopArea := TRUE;
	END_IF;
	
	//Generating alarm category feedback
	IF #i_Category = 1 AND #b_StaAlm THEN
	    #IO_AreaFb.Alm.Alm_Lvl1 := TRUE;
	END_IF;
	
	IF #i_Category = 2 AND #b_StaAlm THEN
	    #IO_AreaFb.Alm.Alm_Lvl2 := TRUE;
	END_IF;
	
	IF #i_Category = 3 AND #b_StaAlm THEN
	    #IO_AreaFb.Alm.Alm_Lvl3 := TRUE;
	END_IF;
	
	//============================================================================================
	IF (#Ob_Fwd AND NOT #b_Old_Ob_Fwd) OR (#Ob_Rev AND NOT #b_Old_Ob_Rev) THEN
	    #Odi_ActCouRst := #Odi_ActCouRst + 1;
	    #Odi_ActCouTot := #Odi_ActCouTot + 1;
	END_IF;
	IF #b_HmiCmdRstActOpe THEN
	    #Odi_ActCouRst := 0;
	END_IF;
	#b_Old_Ob_Fwd := #Ob_Fwd;
	#b_Old_Ob_Rev := #Ob_Rev;
	
	//============================================================================================
	#FB_UTIL_Work_H_Rst(Ib_On := #Ob_Fwd OR #Ob_Rev,
	                    Ib_Reset := #b_HmiCmdRstActOpe,
	                    Ib_Pls1S := "Clock_1Hz",
	                    IOdi_ResultHours := #Odi_RunTimRst);
	
	#FB_UTIL_Work_H_Tot(Ib_On := #Ob_Fwd OR #Ob_Rev,
	                    Ib_Pls1S := "Clock_1Hz",
	                    IOdi_ResultHours := #Odi_RunTimTot);
	
	//============================================================================================
	//Get instantaneous current value from SRW01
	#Or_InstCurr := #w_InstCurr/10;
	
	//============================================================================================
	//Actual Error Code Output
	#Oi_ErrCod := #w_ErrCod;
	
	//============================================================================================
	//Local/Remote Operation
	IF #b_ManutLocal AND #b_StaModMan AND NOT #b_StaModAut AND NOT #b_StaModDis THEN
	    #b_RemoteM := FALSE;
	ELSE
	    #b_RemoteM := TRUE;
	END_IF;
	
	#Ob_Remote := #b_RemoteM;
	
	//Local/Remote Operation
	IF #b_StaModMan AND NOT #b_StaModAut AND NOT #b_StaModDis THEN
	    #b_PerRemMod := TRUE;
	ELSE
	    #b_PerRemMod := FALSE;
	END_IF;
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_CM_DXV"
TITLE = Digital valve
{ S7_Optimized_Access := 'FALSE' }
AUTHOR : Reditech
FAMILY : Typical
VERSION : 0.0
//Reditech standard typical for controlling a digital valve (open/close OR 3-way valve)
   VAR_INPUT 
      Ib_AutPos1 : Bool;   //  automatic command Pos1/open
      Ib_AutPos0 : Bool;   //  automatic command Pos0/close
      Ib_FbPos1 : Bool := TRUE;   //  feedback Pos1/opened (failsafe, 0=Pos1)
      Ib_FbPos0 : Bool := TRUE;   //  feedback Pos0/closed (failsafe, 0=Pos0)
      Ii_ParTFb : Int := 5;   //  time out value for feedback monitoring
      Iby_Saf : Byte := 16#00;   //  8 safety bits : 1=error
      Iby_IlOn : Byte;   //  8 interlock bits : 1 prevents Pos1/opening
      Iby_IlOff : Byte;   //  8 interlock bits : 1 prevents Pos0/closing
      Ib_DisAlmWrn : Bool;
      Iby_CfgActionAlm : Byte;   //  .0=continue / .1=to safe position / .2=STOP
      Iw_Cfg : Word := 16#0001;   //  .0=enable stop / .1=enable continuous output / .2=safe position is Pos1/open
   END_VAR

   VAR_OUTPUT 
      Ob_Pos1 : Bool;   //  control output Pos1/open
      Ob_Pos0 : Bool;   //  control output Pos0/close
      Ob_Stp : Bool := TRUE;   //  control output stop
      Ob_Alm : Bool;   //  general alarm
      Ob_StaPos1 : Bool;   //  Status in position 1
      Ob_StaPos0 : Bool;   //  Status in position 0
      Odi_HmiSta : DInt;   //  State bits for HMI
      Odi_HmiAlm : DInt;   //  Alarm bit for HMI
      Odi_ActCouRst : DInt;   //  Actuation counter from last reset
      Odi_ActCouTot : DInt;   //  Total actuation counter
      Oi_HmiAlm : Int;   //  Alarm bit for HMI
      Oi_HMIStaInd : Int;
   END_VAR

   VAR_IN_OUT 
      IOdi_HmiCmd : DInt;   //  Command bits from HMI
      IO_AreaCmd : "UDT_AreaCmd";   //  Command bits from area
      IO_AreaFb : "UDT_AreaFb";   //  Feedback bits to area
   END_VAR

   VAR 
      i_TmrFbPos1 { ExternalVisible := 'False'} : Int;   //  timer feedback control opening
      i_TmrFbPos0 { ExternalVisible := 'False'} : Int;   //  timer feedback control closing
      b_HmiCmdModAut { ExternalVisible := 'False'} : Bool;   //  command change mode to AUTO
      b_HmiCmdModMan { ExternalVisible := 'False'} : Bool;   //  command change mode to MANUAL
      b_HmiCmdModDis { ExternalVisible := 'False'} : Bool;   //  command change mode to DISABLED
      b_HmiCmdSim { ExternalVisible := 'False'} : Bool;   //  toggle simulation mode
      b_HmiCmdPos1 { ExternalVisible := 'False'} : Bool;   //  command Pos1/ open
      b_HmiCmdPos0 { ExternalVisible := 'False'} : Bool;   //  command Pos0/close
      b_HmiCmdStp { ExternalVisible := 'False'} : Bool;   //  command stop
      b_HmiCmdRst { ExternalVisible := 'False'} : Bool;   //  reset alarms
      b_HmiCmdRstActCou { ExternalVisible := 'False'} : Bool;   //  reset actuation counter
      b_StaModAut { ExternalVisible := 'False'} : Bool;   //  state AUTOMATIC
      b_StaModMan { ExternalVisible := 'False'} : Bool := TRUE;   //  state MANUAL
      b_StaModDis { ExternalVisible := 'False'} : Bool;   //  state DISABLED
      b_StaSim { ExternalVisible := 'False'} : Bool;   //  state simulation ON
      b_StaIlOff { ExternalVisible := 'False'} : Bool;   //  state interlock OFF : 1 = interlocked (prevents Pos0/closing)
      b_StaIlOn { ExternalVisible := 'False'} : Bool;   //  state interlock ON : 1 = interlocked (prevents Pos1/opening)
      b_StaSaf { ExternalVisible := 'False'} : Bool;   //  state safety : 1 = error (valve to safety position)
      b_StaAlm { ExternalVisible := 'False'} : Bool;   //  general alarm
      b_CfgEnOutpAlwaysOn { ExternalVisible := 'False'} : Bool;   //  configuration : Feedback available
      b_CfgSafPosPos1 { ExternalVisible := 'False'} : Bool;   //  configuration : =1 => safe position = Pos1/open
      b_CfgPushToRun { ExternalVisible := 'False'} : Bool;
      b_CfgDisableSim { ExternalVisible := 'False'} : Bool;
      b_CfgStopArea { ExternalVisible := 'False'} : Bool;
      b_CfgAlmActCtn { ExternalVisible := 'False'} : Bool;   //  action after alarm : continue movement
      b_CfgAlmActSaf { ExternalVisible := 'False'} : Bool;   //  action after alarm : go to safety position
      b_CfgAlmActStp { ExternalVisible := 'False'} : Bool;   //  action after alarm : stop
      b_AlmToFb { ExternalVisible := 'False'} : Bool;   //  alarm time out feedback
      b_AlmIncFb { ExternalVisible := 'False'} : Bool;   //  alarm inconsistent feedbacks (two feedbacks together)
      b_AlmIncIl { ExternalVisible := 'False'} : Bool;   //  alarm inconsistent interlocks (two interlocks together)
      b_ReqAut { ExternalVisible := 'False'} : Bool;   //  automatic mode requested
      b_ReqMan { ExternalVisible := 'False'} : Bool;   //  manual mode requested
      b_ReqDis { ExternalVisible := 'False'} : Bool;   //  disabled mode requested
      b_GenCmdAut { ExternalVisible := 'False'} : Bool;   //  general command to automatic mode, can be set by process or HMI, pulse (will be reset)
      b_GenCmdMan { ExternalVisible := 'False'} : Bool;   //  general command to manual mode, can be set by process or HMI, pulse (will be reset)
      b_GenCmdDis { ExternalVisible := 'False'} : Bool;   //  general command to disabled mode, can be set by process or HMI, pulse (will be reset)
      b_CmdManPos1 { ExternalVisible := 'False'} : Bool;   //  internal memo : manual command open
      b_CmdManPos0 { ExternalVisible := 'False'} : Bool;   //  internal memo : manual command close
      b_CmdAutPos1 { ExternalVisible := 'False'} : Bool;   //  internal memo : automatic command open
      b_CmdAutPos0 { ExternalVisible := 'False'} : Bool;   //  internal memo : automatic command close
      b_CmdPos1 { ExternalVisible := 'False'} : Bool;   //  internal memo : command open (combined manual and auto)
      b_CmdPos0 { ExternalVisible := 'False'} : Bool;   //  internal memo : command close (combined manual and auto)
      b_ReqOutPos1 { ExternalVisible := 'False'} : Bool;   //  internal memo : request open = command open after interlocks and faults
      b_ReqOutPos0 { ExternalVisible := 'False'} : Bool;   //  internal memo : request close = command close after interlocks and faults
      b_FbErrPos1 { ExternalVisible := 'False'} : Bool;   //  internal memo : error detection no feedback after opening
      b_FbErrPos0 { ExternalVisible := 'False'} : Bool;   //  internal memo : error detection no feedback after closing
      b_FbSimPos1 { ExternalVisible := 'False'} : Bool;   //  internal feedback simulation value opened
      b_FbSimPos0 { ExternalVisible := 'False'} : Bool;   //  internal feedback simulation value closed
      b_AlActCtn { ExternalVisible := 'False'} : Bool;   //  internal memo action after alarm = continue movement
      b_AlActSaf { ExternalVisible := 'False'} : Bool;   //  internal memo action after alarm = go to safety position
      b_AlActStp { ExternalVisible := 'False'} : Bool;   //  internal memo action after alarm = stop
      b_TFbPos1Out { ExternalVisible := 'False'} : Bool;   //  tmer finished, feedback monitoring Pos1
      b_TFbPos0Out { ExternalVisible := 'False'} : Bool;   //  tmer finished, feedback monitoring Pos0
      b_TSimPos1Out { ExternalVisible := 'False'} : Bool;   //  tmer finished, feedback delay Pos 1 in simulation
      b_TSimPos0Out { ExternalVisible := 'False'} : Bool;   //  tmer finished, feedback delay Pos 0 in simulation
      i_TSimVal { ExternalVisible := 'False'} : Int;   //  internally calculated feedback simulation timer value
      FB_UTIL_TON_Del_1 { ExternalVisible := 'False'} : "FB_UTIL_TON_Sec";
      FB_UTIL_TON_Del_2 { ExternalVisible := 'False'} : "FB_UTIL_TON_Sec";
      FB_UTIL_TON_Del_3 : "FB_UTIL_TON_Sec";
      b_Old_Ob_Pos1 : Bool;
      b_Old_Ob_Pos0 : Bool;
      b_ReqPos1 : Bool;
      b_ReqPos0 : Bool;
      b_CfgEnFbPos1 : Bool;
      b_CfgEnFbPos0 : Bool;
      b_dummy : Bool;
      i_dummy : Int;
      b_StaAlmNew : Bool;
      b_NoAlm : Bool;
      i_AlmAck : Int;
      b_DisAlmWrn : Bool;
      b_RstAlm : Bool;
      i_TmrIncFb : Int;
      b_IncFbErr : Bool;
      I_HmiSta : Word;
      i_Category : Int := 1;   // Device alarm category setting
   END_VAR

   VAR_TEMP 
      di_AUX : DInt;   //  auxiliary double word for calculation of state or alarm word to HMI
   END_VAR


BEGIN
	// =============================================================================================================================  
	// Purpose: Reditech standard typical for controlling a digital valve (open/close OR 3-way valve)
	// -----------------------------------------------------------------------------------------------------------------------------
	// Date (dd MMM yyyy)   Developer                                   Version Comments/Reason for change
	// ..................   .........                                   ....... ..........................
	// 10 Dec 2018          Bram Verheyen                               08.0    Full review
	// 30 Jan 2019          Matthias De Staelen                         08.1    Outputs can be high in simulation mode
	// =============================================================================================================================
	
	//============================================================================================
	#b_CfgEnOutpAlwaysOn := #Iw_Cfg.%X1;
	#b_CfgEnFbPos1 := #Iw_Cfg.%X2;
	#b_CfgEnFbPos0 := #Iw_Cfg.%X3;
	#b_CfgSafPosPos1 := #Iw_Cfg.%X4;
	#b_CfgPushToRun := #Iw_Cfg.%X8;
	#b_CfgDisableSim := #Iw_Cfg.%X10;
	#b_CfgStopArea := #Iw_Cfg.%X11;
	
	//============================================================================================
	#b_DisAlmWrn := #Ib_DisAlmWrn OR #IO_AreaCmd.Alm.Dis OR #b_StaModDis;
	
	//============================================================================================
	#b_StaSaf := (#Iby_Saf <> 0) AND NOT #b_DisAlmWrn;
	#b_StaIlOn := (#Iby_IlOn <> 0);
	#b_StaIlOff := (#Iby_IlOff <> 0);
	
	//============================================================================================
	#b_HmiCmdModAut := #IOdi_HmiCmd.%X0;
	#b_HmiCmdModMan := #IOdi_HmiCmd.%X1;
	#b_HmiCmdModDis := #IOdi_HmiCmd.%X2;
	#b_HmiCmdSim := #IOdi_HmiCmd.%X3;
	#b_HmiCmdPos1 := #IOdi_HmiCmd.%X4;
	#b_HmiCmdPos0 := #IOdi_HmiCmd.%X5;
	#b_HmiCmdStp := #IOdi_HmiCmd.%X6;
	#b_HmiCmdRst := #IOdi_HmiCmd.%X7;
	#b_HmiCmdRstActCou := #IOdi_HmiCmd.%X8;
	
	IF #b_CfgPushToRun THEN
	    #IOdi_HmiCmd := DWORD_TO_DINT(DINT_TO_DWORD(#IOdi_HmiCmd) AND 48);
	ELSE
	    #IOdi_HmiCmd := 0;
	END_IF;
	
	//============================================================================================
	IF #IO_AreaCmd.Mode.AreaMode THEN
	    #b_ReqAut := #IO_AreaCmd.Mode.Auto;
	    #b_ReqMan := #IO_AreaCmd.Mode.Man;
	    #b_ReqDis := #IO_AreaCmd.Mode.Dis;
	ELSE
	    #b_ReqAut := #b_HmiCmdModAut;
	    #b_ReqMan := #b_HmiCmdModMan;
	    #b_ReqDis := #b_HmiCmdModDis;
	END_IF;
	
	IF (#b_ReqAut AND NOT #b_ReqMan AND NOT #b_ReqDis) THEN
	    #b_StaModAut := true;
	    #b_StaModMan := false;
	    #b_StaModDis := false;
	END_IF;
	IF (#b_ReqMan AND NOT #b_ReqAut AND NOT #b_ReqDis) THEN
	    #b_StaModAut := false;
	    #b_StaModMan := true;
	    #b_StaModDis := false;
	END_IF;
	IF (#b_ReqDis AND NOT #b_ReqAut AND NOT #b_ReqMan) THEN
	    #b_StaModAut := false;
	    #b_StaModMan := false;
	    #b_StaModDis := true;
	END_IF;
	
	//============================================================================================
	IF #IO_AreaCmd.Sim.ForceOn OR (#b_HmiCmdSim AND NOT #b_StaSim AND NOT #IO_AreaCmd.Sim.ForceOn AND NOT #IO_AreaCmd.Sim.ForceOff) THEN
	    #b_StaSim := true;
	    #b_HmiCmdSim := false; // reset of command necessary, else simulation will always be reset immediately by following instructions
	END_IF;
	IF #IO_AreaCmd.Sim.ForceOff OR (#b_HmiCmdSim AND #b_StaSim AND NOT #IO_AreaCmd.Sim.ForceOn AND NOT #IO_AreaCmd.Sim.ForceOff) THEN
	    #b_StaSim := false;
	    #b_HmiCmdSim := false;
	END_IF;
	
	//============================================================================================
	#b_AlActCtn := #Iby_CfgActionAlm.%X0;
	#b_AlActSaf := #Iby_CfgActionAlm.%X1;
	#b_AlActStp := #Iby_CfgActionAlm.%X2;
	
	#b_CfgAlmActCtn := #b_AlActCtn OR (NOT #b_AlActCtn AND NOT #b_AlActSaf AND NOT #b_AlActStp);
	#b_CfgAlmActSaf := (NOT #b_AlActCtn AND #b_AlActSaf);
	#b_CfgAlmActStp := (NOT #b_AlActCtn AND NOT #b_AlActSaf AND #b_AlActStp);
	
	//============================================================================================
	IF (#b_ReqPos1 AND NOT #b_FbSimPos1) OR (#b_ReqPos0 AND NOT #b_FbSimPos0) THEN
	    #b_FbSimPos1 := false;
	    #b_FbSimPos0 := false;
	END_IF;
	IF ((#i_TmrFbPos1 <= 1) OR #Ii_ParTFb = 0) AND #b_ReqPos1 THEN
	    #b_FbSimPos1 := true;
	    #b_FbSimPos0 := false;
	END_IF;
	IF ((#i_TmrFbPos0 <= 1) OR #Ii_ParTFb = 0) AND #b_ReqPos0 THEN
	    #b_FbSimPos1 := false;
	    #b_FbSimPos0 := true;
	END_IF;
	
	//============================================================================================
	#Ob_StaPos1 := (#b_CfgEnFbPos1 AND #Ib_FbPos1 AND NOT #b_StaSim)
	OR (NOT #b_CfgEnFbPos1 AND #b_FbSimPos1)
	OR (#b_StaSim AND #b_FbSimPos1);
	#Ob_StaPos0 := (#b_CfgEnFbPos0 AND #Ib_FbPos0 AND NOT #b_StaSim)
	OR (NOT #b_CfgEnFbPos0 AND #b_FbSimPos0)
	OR (#b_StaSim AND #b_FbSimPos0);
	
	//============================================================================================
	#b_NoAlm := false;
	#b_RstAlm := #b_HmiCmdRst OR #IO_AreaCmd.Alm.Rst;
	"FC_UTIL_AlmAck"(Ib_CmdAck := #b_RstAlm,
	                 Oi_StaAlm => #i_dummy,
	                 Ob_StaAlm => #b_dummy,
	                 Ob_StaNewAlm => #b_StaAlmNew,
	                 IO_Alm0 := #b_AlmToFb,
	                 IO_Alm1 := #b_AlmIncFb,
	                 IO_Alm2 := #b_AlmIncIl,
	                 IO_Alm3 := #b_NoAlm,
	                 IO_Alm4 := #b_NoAlm,
	                 IO_Alm5 := #b_NoAlm,
	                 IO_Alm6 := #b_NoAlm,
	                 IO_Alm7 := #b_NoAlm,
	                 IO_Alm8 := #b_NoAlm,
	                 IO_Alm9 := #b_NoAlm,
	                 IO_Alm10 := #b_NoAlm,
	                 IO_Alm11 := #b_NoAlm,
	                 IO_Alm12 := #b_NoAlm,
	                 IO_Alm13 := #b_NoAlm,
	                 IO_Alm14 := #b_NoAlm,
	                 IO_Alm15 := #b_NoAlm,
	                 IOi_StaAck := #i_AlmAck);
	
	//============================================================================================
	IF (#Ii_ParTFb > 0) THEN  // only when time value > 0
	    #FB_UTIL_TON_Del_1(Ii_tValue := #Ii_ParTFb,
	                       Ib_In := (#b_ReqPos1 AND NOT #Ob_StaPos1),
	                       Ii_Base := 1,
	                       Ib_Hold := 0,
	                       Ob_Out => #b_FbErrPos1,
	                       Oi_tmrValue => #i_TmrFbPos1);
	END_IF;
	
	IF (#Ii_ParTFb > 0) THEN  // only when time value > 0
	    #FB_UTIL_TON_Del_2(Ii_tValue := #Ii_ParTFb,
	                       Ib_In := (#b_ReqPos0 AND NOT #Ob_StaPos0),
	                       Ii_Base := 1,
	                       Ib_Hold := 0,
	                       Ob_Out => #b_FbErrPos0,
	                       Oi_tmrValue => #i_TmrFbPos0);
	END_IF;
	
	IF ((#b_FbErrPos0 OR #b_FbErrPos1) AND (#Ii_ParTFb > 0)) AND NOT #b_DisAlmWrn THEN
	    #b_AlmToFb := true;
	END_IF;
	
	//============================================================================================
	IF (#Ii_ParTFb > 0) THEN  // only when time value > 0
	    #FB_UTIL_TON_Del_3(Ii_tValue := #Ii_ParTFb,
	                       Ib_In := (#Ob_StaPos1 AND #Ob_StaPos0),
	                       Ii_Base := 1,
	                       Ib_Hold := 0,
	                       Ob_Out => #b_IncFbErr,
	                       Oi_tmrValue => #i_TmrIncFb);
	END_IF;
	
	IF (#Ob_StaPos1 AND #Ob_StaPos0 AND #b_IncFbErr) AND NOT #b_DisAlmWrn THEN
	    #b_AlmIncFb := true;
	END_IF;
	
	//============================================================================================        
	IF (#b_StaIlOn AND #b_StaIlOff) AND NOT #b_DisAlmWrn THEN
	    #b_AlmIncIl := true;
	END_IF;
	IF NOT (#b_StaIlOn AND #b_StaIlOff) THEN
	    #b_AlmIncIl := false;
	END_IF;
	
	//============================================================================================
	#b_StaAlm := #b_AlmToFb OR #b_StaSaf OR #b_AlmIncFb OR #b_AlmIncIl;
	#Ob_Alm := #b_StaAlm;
	
	//============================================================================================
	#b_CmdAutPos1 := #Ib_AutPos1;
	#b_CmdAutPos0 := #Ib_AutPos0;
	
	IF #b_StaModAut THEN
	    #b_CmdManPos1 := #b_CmdAutPos1;
	    #b_CmdManPos0 := #b_CmdAutPos0;
	END_IF;
	
	//============================================================================================
	IF #b_StaModMan AND NOT #b_CfgPushToRun THEN
	    IF (#b_HmiCmdPos1 OR (#b_StaSaf AND #b_CfgSafPosPos1) OR (#b_AlmToFb AND #b_CfgAlmActSaf AND #b_CfgSafPosPos1)) THEN
	        #b_CmdManPos1 := true;
	        #b_CmdManPos0 := false;
	    END_IF;
	    IF (#b_HmiCmdPos0 OR (#b_StaSaf AND NOT #b_CfgSafPosPos1) OR (#b_AlmToFb AND #b_CfgAlmActSaf AND NOT #b_CfgSafPosPos1)) THEN
	        #b_CmdManPos1 := false;
	        #b_CmdManPos0 := true;
	    END_IF;
	    IF #b_HmiCmdStp OR #b_StaAlm OR #b_StaModDis THEN
	        #b_CmdManPos1 := false;
	        #b_CmdManPos0 := false;
	    END_IF;
	END_IF;
	
	IF #b_StaModMan AND #b_CfgPushToRun THEN
	    #b_CmdManPos1 := ((#b_HmiCmdPos1 AND NOT #b_HmiCmdPos0)
	    OR (#b_StaSaf AND #b_CfgSafPosPos1)
	    OR (#b_AlmToFb AND #b_CfgAlmActSaf AND #b_CfgSafPosPos1)) AND NOT (#b_AlmToFb AND #b_CfgAlmActStp)
	    AND NOT #b_StaModDis;
	    #b_CmdManPos0 := ((#b_HmiCmdPos0 AND NOT #b_HmiCmdPos1)
	    OR (#b_StaSaf AND NOT #b_CfgSafPosPos1)
	    OR (#b_AlmToFb AND #b_CfgAlmActSaf AND NOT #b_CfgSafPosPos1)) AND NOT (#b_AlmToFb AND #b_CfgAlmActStp)
	    AND NOT #b_StaModDis;
	END_IF;
	
	IF NOT #b_StaModMan OR #b_StaModDis THEN
	    #b_CmdManPos1 := false;
	    #b_CmdManPos0 := false;
	END_IF;
	
	
	
	
	//============================================================================================
	#b_CmdPos1 := (#b_StaModAut AND #b_CmdAutPos1) OR (#b_StaModMan AND #b_CmdManPos1);
	#b_CmdPos0 := (#b_StaModAut AND #b_CmdAutPos0) OR (#b_StaModMan AND #b_CmdManPos0);
	
	//============================================================================================
	#b_ReqOutPos1 := (#b_CmdPos1 AND NOT #b_StaAlm AND NOT #b_StaIlOn)
	OR (#b_CmdPos1 AND #b_StaAlm AND NOT #b_StaSaf AND #b_CfgAlmActCtn)
	OR (#b_StaIlOff AND NOT #b_StaAlm AND NOT #b_StaIlOn)
	OR (#b_StaSaf AND #b_CfgSafPosPos1)
	OR (#b_AlmToFb AND #b_CfgAlmActSaf AND #b_CfgSafPosPos1);
	
	#b_ReqOutPos0 := (#b_CmdPos0 AND NOT #b_StaAlm AND NOT #b_StaIlOff)
	OR (#b_CmdPos0 AND #b_StaAlm AND NOT #b_StaSaf AND #b_CfgAlmActCtn)
	OR (#b_StaIlOn AND NOT #b_StaAlm AND NOT #b_StaIlOff)
	OR (#b_StaSaf AND NOT #b_CfgSafPosPos1)
	OR (#b_AlmToFb AND #b_CfgAlmActSaf AND NOT #b_CfgSafPosPos1);
	
	#b_ReqPos1 := (#b_ReqOutPos1 AND #b_CfgEnOutpAlwaysOn)
	OR (#b_ReqOutPos1 AND NOT #b_CfgEnOutpAlwaysOn AND NOT #Ob_StaPos1)
	AND NOT #b_StaModDis;
	#b_ReqPos0 := (#b_ReqOutPos0 AND #b_CfgEnOutpAlwaysOn)
	OR (#b_ReqOutPos0 AND NOT #b_CfgEnOutpAlwaysOn AND NOT #Ob_StaPos0)
	AND NOT #b_StaModDis;
	
	//============================================================================================
	#Ob_Pos0 := #b_ReqPos0;
	#Ob_Pos1 := #b_ReqPos1;
	#Ob_Stp := NOT #Ob_Pos0 AND NOT #Ob_Pos1;
	
	//============================================================================================
	#Odi_HmiSta.%X0 := #b_StaModAut;
	#Odi_HmiSta.%X1 := #b_StaModMan;
	#Odi_HmiSta.%X2 := #b_StaModDis;
	#Odi_HmiSta.%X3 := #b_StaSim;
	#Odi_HmiSta.%X4 := #b_StaIlOff;
	#Odi_HmiSta.%X5 := #b_StaIlOn;
	#Odi_HmiSta.%X6 := #b_StaSaf;
	#Odi_HmiSta.%X16 := #b_ReqPos1;
	#Odi_HmiSta.%X17 := #b_ReqPos0;
	#Odi_HmiSta.%X18 := #Ob_StaPos1 AND NOT #b_StaAlm;
	#Odi_HmiSta.%X19 := #Ob_StaPos0 AND NOT #b_StaAlm;
	#Odi_HmiSta.%X20 := #b_StaAlm;
	#Odi_HmiSta.%X28 := #IO_AreaCmd.Mode.AreaMode;
	#Odi_HmiSta.%X29 := #b_CfgAlmActCtn;
	#Odi_HmiSta.%X30 := #b_CfgAlmActSaf;
	#Odi_HmiSta.%X31 := #b_CfgAlmActStp;
	
	#Oi_HMIStaInd.%X0 := 0;
	#Oi_HMIStaInd.%X0 := #b_StaModAut;
	#Oi_HMIStaInd.%X1 := #b_StaModMan;
	#Oi_HMIStaInd.%X2 := #b_StaModDis;
	#Oi_HMIStaInd.%X3 := #b_StaSim;
	#Oi_HMIStaInd.%X4 := #b_StaAlm;
	#Oi_HMIStaInd.%X5 := #Ob_StaPos1 AND NOT #b_StaAlm;
	#Oi_HMIStaInd.%X6 := #Ob_StaPos0 AND NOT #b_StaAlm;
	
	#I_HmiSta.%X0 := #b_StaModAut;
	#I_HmiSta.%X1 := #b_StaModMan;
	#I_HmiSta.%X2 := #b_StaModDis;
	#I_HmiSta.%X3 := #b_StaSim;
	#I_HmiSta.%X4 := #b_StaIlOn;
	#I_HmiSta.%X5 := #b_StaIlOff;
	#I_HmiSta.%X6 := #Ob_StaPos1;
	#I_HmiSta.%X7 := #Ob_StaPos0;
	#I_HmiSta.%X8 := #b_StaAlm;
	
	//============================================================================================
	#di_AUX := 0;
	#di_AUX.%X0 := #b_AlmToFb;
	#di_AUX.%X1 := #b_AlmIncFb;
	#di_AUX.%X2 := #b_AlmIncIl;
	#di_AUX.%X8 := #Iby_IlOff.%X0;
	#di_AUX.%X9 := #Iby_IlOff.%X1;
	#di_AUX.%X10 := #Iby_IlOff.%X2;
	#di_AUX.%X11 := #Iby_IlOff.%X3;
	#di_AUX.%X12 := #Iby_IlOff.%X4;
	#di_AUX.%X13 := #Iby_IlOff.%X5;
	#di_AUX.%X14 := #Iby_IlOff.%X6;
	#di_AUX.%X15 := #Iby_IlOff.%X7;
	#di_AUX.%X16 := #Iby_IlOn.%X0;
	#di_AUX.%X17 := #Iby_IlOn.%X1;
	#di_AUX.%X18 := #Iby_IlOn.%X2;
	#di_AUX.%X19 := #Iby_IlOn.%X3;
	#di_AUX.%X20 := #Iby_IlOn.%X4;
	#di_AUX.%X21 := #Iby_IlOn.%X5;
	#di_AUX.%X22 := #Iby_IlOn.%X6;
	#di_AUX.%X23 := #Iby_IlOn.%X7;
	#di_AUX.%X24 := #Iby_Saf.%X0;
	#di_AUX.%X25 := #Iby_Saf.%X1;
	#di_AUX.%X26 := #Iby_Saf.%X2;
	#di_AUX.%X27 := #Iby_Saf.%X3;
	#di_AUX.%X28 := #Iby_Saf.%X4;
	#di_AUX.%X29 := #Iby_Saf.%X5;
	#di_AUX.%X30 := #Iby_Saf.%X6;
	#di_AUX.%X31 := #Iby_Saf.%X7;
	#Odi_HmiAlm := #di_AUX;
	
	//============================================================================================
	#di_AUX := 0;
	#di_AUX.%X0 := #b_AlmToFb;
	#di_AUX.%X1 := #b_AlmIncFb;
	#di_AUX.%X2 := #b_AlmIncIl;
	#Oi_HmiAlm := DINT_TO_INT(#di_AUX);
	
	//============================================================================================
	IF #b_StaModDis THEN
	    #IO_AreaFb.Mode.Dis := TRUE;
	END_IF;
	IF #b_StaModMan THEN
	    #IO_AreaFb.Mode.Man := TRUE;
	END_IF;
	IF #b_StaModAut THEN
	    #IO_AreaFb.Mode.Auto := TRUE;
	END_IF;
	IF #b_StaAlm THEN
	    #IO_AreaFb.Alm.Alm := TRUE;
	END_IF;
	IF #b_StaAlmNew THEN
	    #IO_AreaFb.Alm.New := TRUE;
	END_IF;
	IF #b_StaAlm AND #b_CfgStopArea THEN
	    #IO_AreaFb.Alm.StopArea := TRUE;
	END_IF;
	IF #b_StaSim THEN
	    #IO_AreaFb.Sim.Sim := TRUE;
	END_IF;
	
	//Generating alarm category feedback
	IF #i_Category = 1 AND #b_StaAlm THEN
	    #IO_AreaFb.Alm.Alm_Lvl1 := TRUE;
	END_IF;
	
	IF #i_Category = 2 AND #b_StaAlm THEN
	    #IO_AreaFb.Alm.Alm_Lvl2 := TRUE;
	END_IF;
	
	IF #i_Category = 3 AND #b_StaAlm THEN
	    #IO_AreaFb.Alm.Alm_Lvl3 := TRUE;
	END_IF;
	
	//============================================================================================
	IF (#Ob_Pos0 AND NOT #b_Old_Ob_Pos0) OR (#Ob_Pos1 AND NOT #b_Old_Ob_Pos1) THEN
	    #Odi_ActCouRst := #Odi_ActCouRst + 1;
	    #Odi_ActCouTot := #Odi_ActCouTot + 1;
	END_IF;
	IF #b_HmiCmdRstActCou THEN
	    #Odi_ActCouRst := 0;
	END_IF;
	#b_Old_Ob_Pos0 := #Ob_Pos0;
	#b_Old_Ob_Pos1 := #Ob_Pos1;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_CM_DI"
TITLE = Digital input
{ S7_Optimized_Access := 'FALSE' }
AUTHOR : Reditech
FAMILY : Typical
VERSION : 0.0
//Reditech standard typical for controlling a digital input (switch) inversion is possible, input is delayed
   VAR_INPUT 
      Ib_InRaw : Bool;   //  digital input
      Ib_Inv : Bool;   //  invert digital input
      Ii_ParTOn : Int;   //  time delay value ON
      Ii_ParTOff : Int;   //  time delay value OFF
      Ib_EnAlmIfzero : Bool;
      Ib_EnAlmIfOne : Bool;
      Ib_EnWrnIfzero : Bool;
      Ib_EnWrnIfOne : Bool;
      Ib_DisAlmWrn : Bool;
      Iw_Cfg : Word;   //  .0=alarm if out = 0 / .1=alarm if out = 1 / .2=automatic alarm reset / .4 = warning if out =0 / .5 = warning if out =1
   END_VAR

   VAR_OUTPUT 
      Ob_Out : Bool;   //  Output value
      Ob_Alm : Bool;   //  general alarm
      Ob_Wrn : Bool;   //  general warning
      Odi_HmiSta : DInt;   //  State bits for HMI
      Odi_HmiAlm : DInt;   //  Alarm bit for HMI
      Oi_HmiAlm : Int;   //  Alarm bit for HMI
   END_VAR

   VAR_IN_OUT 
      IOdi_HmiCmd : DInt;   //  Command bits from HMI
      IO_AreaCmd : "UDT_AreaCmd";   //  Command bits from area
      IO_AreaFb : "UDT_AreaFb";   //  Feedback bits to area
   END_VAR

   VAR 
      i_TmrOn { ExternalVisible := 'False'} : Int;   //  actual timer value delay ON
      i_TmrOff { ExternalVisible := 'False'} : Int;   //  actual timer value delay OFF
      b_HmiCmdSim { ExternalVisible := 'False'} : Bool;   //  command (toggle) simulation mode
      b_HmiCmdSimValOn { ExternalVisible := 'False'} : Bool;   //  set simulation value on
      b_HmiCmdSimValOff { ExternalVisible := 'False'} : Bool;   //  set simulation value off
      b_HmiCmdRst { ExternalVisible := 'False'} : Bool;   //  reset alarm
      b_StaSim { ExternalVisible := 'False'} : Bool;   //  simulation mode on
      b_StaInRaw { ExternalVisible := 'False'} : Bool;   //  copy of input value
      b_StaAlm { ExternalVisible := 'False'} : Bool;   //  alarm
      b_StaOut { ExternalVisible := 'False'} : Bool;   //  output
      b_StaWrn { ExternalVisible := 'False'} : Bool;   //  warning
      b_CfgAutoReset { ExternalVisible := 'False'} : Bool;   //  automatic alarm reset
      b_CfgStopArea { ExternalVisible := 'False'} : Bool;
      b_Alm { ExternalVisible := 'False'} : Bool;   //  alarm
      b_Wrn { ExternalVisible := 'False'} : Bool;   //  warning
      b_In { ExternalVisible := 'False'} : Bool;   //  auxiliary bit for input value before delays
      b_TOnOut { ExternalVisible := 'False'} : Bool;   //  time delay ON finished
      b_TOffOut { ExternalVisible := 'False'} : Bool;   //  time delay OFF finished
      Fb_UTIL_Ton_Del { ExternalVisible := 'False'} : "FB_UTIL_TON_Sec";
      FB_UTIL_TOF_Del { ExternalVisible := 'False'} : "FB_UTIL_TON_Sec";
      b_DisAlmWrn : Bool;
      b_dummy : Bool;
      i_dummy : Int;
      b_StaAlmNew : Bool;
      b_NoAlm : Bool;
      i_AlmAck : Int;
      b_DisAlmWrn_1 : Bool;
      b_RstAlm : Bool;
      i_Category : Int;   // Device alarm category setting
   END_VAR

   VAR_TEMP 
      di_AUX : DInt;   //  auxiliary double word for calculation of state or alarm word to HMI
   END_VAR


BEGIN
	// =========================================================================================================================  
	// Purpose: Reditech standard typical for controlling a digital input (switch) inversion is possible, input is delayed
	// -------------------------------------------------------------------------------------------------------------------------
	// Date (dd MMM yyyy)   Developer                                   Version Comments/Reason for change
	// ..................   .........                                   ....... ..........................
	// 18 Dec 2018          Bram Verheyen                               09.0    Full review
	// =========================================================================================================================
	
	//============================================================================================
	#b_CfgAutoReset := #Iw_Cfg.%X2;
	#b_CfgStopArea := #Iw_Cfg.%X11;
	
	//============================================================================================
	#b_DisAlmWrn := #Ib_DisAlmWrn OR #IO_AreaCmd.Alm.Dis;
	
	//============================================================================================
	#b_HmiCmdSim := #IOdi_HmiCmd.%X0;
	#b_HmiCmdSimValOn := #IOdi_HmiCmd.%X1;
	#b_HmiCmdSimValOff := #IOdi_HmiCmd.%X2;
	#b_HmiCmdRst := #IOdi_HmiCmd.%X3;
	#IOdi_HmiCmd := 0;
	
	//============================================================================================
	IF #IO_AreaCmd.Sim.ForceOn OR (#b_HmiCmdSim AND NOT #b_StaSim AND NOT #IO_AreaCmd.Sim.ForceOn AND NOT #IO_AreaCmd.Sim.ForceOff) THEN
	    #b_StaSim := true;
	    #b_HmiCmdSim := false; // reset of command necessary, else simulation will always be reset immediately by following instructions
	END_IF;
	IF #IO_AreaCmd.Sim.ForceOff OR (#b_HmiCmdSim AND #b_StaSim AND NOT #IO_AreaCmd.Sim.ForceOn AND NOT #IO_AreaCmd.Sim.ForceOff) THEN
	    #b_StaSim := false;
	    #b_HmiCmdSim := false;
	END_IF;
	
	//============================================================================================
	IF NOT #b_StaSim THEN
	    IF NOT #Ib_Inv THEN
	        #b_In := #Ib_InRaw;
	    ELSE
	        #b_In := NOT #Ib_InRaw;
	    END_IF;
	    #b_StaInRaw := #Ib_InRaw;
	ELSE
	    IF #b_HmiCmdSimValOn THEN
	        #b_In := true;
	    END_IF;
	    IF #b_HmiCmdSimValOff THEN
	        #b_In := false;
	    END_IF;
	    #b_StaInRaw := #b_In;
	END_IF;
	
	//============================================================================================
	#Fb_UTIL_Ton_Del(Ii_tValue := #Ii_ParTOn,
	                 Ib_In := #b_In AND (#Ib_EnAlmIfOne OR #Ib_EnWrnIfOne) AND NOT #b_DisAlmWrn,
	                 Ii_Base := 1,
	                 Ib_Hold := 0,
	                 Ob_Out => #b_TOnOut,
	                 Oi_tmrValue => #i_TmrOn);
	
	#FB_UTIL_TOF_Del(Ii_tValue := #Ii_ParTOff,
	                 Ib_In := (NOT #b_In AND (#Ib_EnAlmIfzero OR #Ib_EnWrnIfzero) AND NOT #b_DisAlmWrn),
	                 Ii_Base := 1,
	                 Ib_Hold := 0,
	                 Ob_Out => #b_TOffOut,
	                 Oi_tmrValue => #i_TmrOff);
	
	#b_StaOut := #b_In;
	//============================================================================================
	#b_NoAlm := false;
	#b_RstAlm := #b_HmiCmdRst OR #IO_AreaCmd.Alm.Rst OR #b_CfgAutoReset;
	"FC_UTIL_AlmAck"(Ib_CmdAck := #b_RstAlm,
	                 Oi_StaAlm => #i_dummy,
	                 Ob_StaAlm => #b_dummy,
	                 Ob_StaNewAlm => #b_StaAlmNew,
	                 IO_Alm0 := #b_Alm,
	                 IO_Alm1 := #b_Wrn,
	                 IO_Alm2 := #b_NoAlm,
	                 IO_Alm3 := #b_NoAlm,
	                 IO_Alm4 := #b_NoAlm,
	                 IO_Alm5 := #b_NoAlm,
	                 IO_Alm6 := #b_NoAlm,
	                 IO_Alm7 := #b_NoAlm,
	                 IO_Alm8 := #b_NoAlm,
	                 IO_Alm9 := #b_NoAlm,
	                 IO_Alm10 := #b_NoAlm,
	                 IO_Alm11 := #b_NoAlm,
	                 IO_Alm12 := #b_NoAlm,
	                 IO_Alm13 := #b_NoAlm,
	                 IO_Alm14 := #b_NoAlm,
	                 IO_Alm15 := #b_NoAlm,
	                 IOi_StaAck := #i_AlmAck);
	
	//============================================================================================
	IF ((#b_TOnOut AND #Ib_EnAlmIfOne) OR (#b_TOffOut AND #Ib_EnAlmIfzero)) AND NOT #b_DisAlmWrn THEN
	    #b_Alm := true;
	    
	END_IF;
	
	//============================================================================================
	IF ((#b_TOnOut AND #Ib_EnWrnIfOne) OR (#b_TOffOut AND #Ib_EnWrnIfzero)) AND NOT #b_DisAlmWrn THEN
	    #b_Wrn := true;
	END_IF;
	
	//============================================================================================
	#b_StaAlm := #b_Alm;
	#Ob_Alm := #b_Alm;
	
	//============================================================================================
	#b_StaWrn := #b_Wrn;
	#Ob_Wrn := #b_Wrn;
	
	//============================================================================================
	#Ob_Out := #b_StaOut;
	
	//============================================================================================
	#Odi_HmiSta.%X0 := #b_StaSim;
	#Odi_HmiSta.%X1 := #b_StaInRaw;
	#Odi_HmiSta.%X16 := #b_StaAlm;
	#Odi_HmiSta.%X17 := #b_StaOut;
	#Odi_HmiSta.%X18 := #b_StaWrn;
	#Odi_HmiSta.%X28 := #IO_AreaCmd.Mode.AreaMode;
	
	//Sending data to HMI for animated alarm category
	#Odi_HmiSta.%X8 := #i_Category = 1 AND #b_StaAlm;
	#Odi_HmiSta.%X9 := #i_Category = 2 AND #b_StaAlm;
	#Odi_HmiSta.%X19 := #i_Category = 3 AND #b_StaAlm;
	
	//============================================================================================
	#di_AUX := 0;
	#di_AUX.%X0 := #b_Alm;
	#di_AUX.%X1 := #b_Wrn;
	#Odi_HmiAlm := #di_AUX;
	#Oi_HmiAlm := DINT_TO_INT(#Odi_HmiAlm);
	
	//============================================================================================
	IF #b_StaAlm THEN
	    #IO_AreaFb.Alm.Alm := TRUE;
	END_IF;
	IF #b_StaWrn THEN
	    #IO_AreaFb.Alm.Wrn := TRUE;
	END_IF;
	IF #b_StaSim THEN
	    #IO_AreaFb.Sim.Sim := TRUE;
	END_IF;
	IF #b_StaAlmNew THEN
	    #IO_AreaFb.Alm.New := TRUE;
	END_IF;
	IF #b_StaAlm AND #b_CfgStopArea THEN
	    #IO_AreaFb.Alm.StopArea := TRUE;
	END_IF;
	
	//Generating alarm category feedback
	IF #i_Category = 1 AND #b_StaAlm THEN
	    #IO_AreaFb.Alm.Alm_Lvl1 := TRUE;
	END_IF;
	
	IF #i_Category = 2 AND #b_StaAlm THEN
	    #IO_AreaFb.Alm.Alm_Lvl2 := TRUE;
	END_IF;
	
	IF #i_Category = 3 AND #b_StaAlm THEN
	    #IO_AreaFb.Alm.Alm_Lvl3 := TRUE;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_EM_Lvl"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
   VAR_INPUT 
      Ib_RequestEqp { ExternalVisible := 'False'} : Bool;   //  Request equipment Command
      Ib_LvlOff_FirstEqp : Bool;   //  Level switch low low
      Ib_LvlOff_SecondEqp : Bool;   //  Level switch low
      Ib_LvlOn_FirstEqp : Bool;   //  Level switch high
      Ib_LvlOn_SecondEqp : Bool;   //  Level switch High High
      Ib_NrEqp : Bool;   //  Number of equipment used at the same time, 0 = 1 eqp, 1 = 2 eqp
   END_VAR

   VAR_OUTPUT 
      Ob_ReqFirstEqp : Bool;   //  Request first equipment
      Ob_ReqSecondEqp : Bool;   //  Request second equipment
   END_VAR

   VAR_IN_OUT 
      IO_AreaCmd : "UDT_AreaCmd";   //  Command bits from area
      IO_AreaFb : "UDT_AreaFb";   //  Feedback bits to area
   END_VAR

   VAR 
      b_FirstEqpReq : Bool;   //  Request to Equipment 1
      b_SecondEqpReq : Bool;   //  Request to Equipment 2
      b_ReqAut : Bool;   //  Request automatic mode
      b_ReqMan : Bool;
      b_ReqDis : Bool;
   END_VAR


BEGIN
	//not used// =========================================================================================================================  
	// Purpose: Reditech standard typical for controlling Pump Toggle manual automatic or semi-automatic
	// -------------------------------------------------------------------------------------------------------------------------
	// Date (dd MMM yyyy)   Developer                                   Version Comments/Reason for change
	// ..................   .........                                   ....... ..........................
	// 16 OCT 2018          Robin Cardinaels                               01      Initial (creation)
	
	// =========================================================================================================================
	// copy command bits from HMI and reset
	
	#b_ReqAut := #IO_AreaCmd.Mode.Auto;
	#b_ReqMan := #IO_AreaCmd.Mode.Man;
	#b_ReqDis := #IO_AreaCmd.Mode.Dis;
	
	IF NOT #b_ReqAut THEN
	    #b_FirstEqpReq := #b_SecondEqpReq := false;
	ELSE
	    IF #Ib_LvlOn_FirstEqp THEN
	        #b_FirstEqpReq := TRUE;
	    END_IF;
	    IF #Ib_LvlOff_FirstEqp THEN
	        #b_FirstEqpReq := FALSE;
	    END_IF;
	    
	    IF #Ib_NrEqp THEN
	        // setting control bits for anaog and digital control.
	        IF #Ib_LvlOn_SecondEqp THEN
	            #b_SecondEqpReq := TRUE;
	        END_IF;
	        IF #Ib_LvlOff_SecondEqp THEN
	            #b_SecondEqpReq := FALSE;
	        END_IF;
	    ELSE
	        #b_SecondEqpReq := false;
	    END_IF;
	END_IF;
	
	// Set Output For Motor 1
	#Ob_ReqFirstEqp := #Ib_RequestEqp AND #b_FirstEqpReq;
	
	//Set output for Motor 2
	#Ob_ReqSecondEqp := #Ib_RequestEqp AND #b_SecondEqpReq;
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_EM_Toggle_2Eqp"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
   VAR_INPUT 
      Ib_RequestEqp : Bool;   //  Request equipment Command
      Ib_RequestCompEqp : Bool;   //  Request complementary equipment Command
      Ib_ExtToggle : Bool;   //  External Manual toggle
      Ib_Eqp1Fb : Bool;   //  Equipment 1 Running / Open
      Ib_Eqp1Error : Bool;   //  Equipment 1 Error
      Ii_Eqp1OpHours : DInt;   //  Equipment 1 operating hours
      Ib_Eqp2Fb : Bool;   //  Equipment 2 Running / Open
      Ib_Eqp2Error : Bool;   //  Equipment 2 Error
      Ii_Eqp2OpHours : DInt;   //  Equipment 2 Operating hours
      Ii_TBlckStrt : Int;   //  Block simultaniuos Strting time
      Ib_EqpComp : Bool;   //  The equipment complement each other
      Ib_CfgTogRun : Bool;   //  Toggle on running hours
      Ib_EnMan : Bool;   //  Enable manual action
   END_VAR

   VAR_OUTPUT 
      Ob_ReqEqp1 : Bool;   //  Request Equipment 1
      Ob_ReqEqp2 : Bool;   //  Request Equipment 2
      Ob_Alm : Bool;   //  General alarm
      Ob_Wrn : Bool;   //  General warning
      Odi_HmiSta : DInt;   //  State bits for HMI
      Odi_HmiAlm : DInt;   //  Alarm bits for HMI
      Oi_HmiAlm : Int;   //  Alarm bits for HMI
   END_VAR

   VAR_IN_OUT 
      IOdi_HmiFcnCmd : DInt;   //  .0: automatic/ .1:semiauto/ .2:manual
      IOdi_HmiCmd : DInt;   //  Command bits from HMI
      IO_AreaCmd : "UDT_AreaCmd";   //  Command bits from area
      IO_AreaFb : "UDT_AreaFb";   //  Feedback bits to area
   END_VAR

   VAR 
      b_HmiCmdModAut : Bool;   //  HMI Command Automatic mode
      b_HmiCmdRst : Bool;   //  HMI Command Reset
      b_HmiCmdModMan : Bool;   //  HMI Command Manual mode
      b_HmiCmdModDis : Bool;   //  HMI Command disabled Mode
      b_HmiCmdFrcEqp1First : Bool;   //  HMI Command Force equipment 1 first
      b_HmiCmdFrcEqp2First : Bool;   //  HMI Command Force equipment 2 first
      b_HmiFcnCmdAuto : Bool := TRUE;   //  HMI Functional command automatic mode
      b_HmiFcnCmdManual : Bool;   //  HMI Functional command manual mode
      b_HmiStaAlm : Bool;   //  HMI Status alarm
      b_HmiStaModAut : Bool;   //  HMI status Ready
      b_HmiStaModMan : Bool;   //  HMI Status Running
      b_HmiStaModDis : Bool;   //  HMI status Preference Eqp
      b_HmiStaFcnAuto : Bool := TRUE;   //  HMI Status Fuction auto switch enabled
      b_HmiStaFcnMan : Bool;   //  HMI Status Fuction manual switch enabled
      b_HmiStaOff : Bool;   //  HMI Status OFF
      b_HmiStaReady : Bool;   //  HMI Status Ready
      b_HmiStaRunning : Bool;   //  HMI Status Running
      b_HmiStaPref1 : Bool;   //  HMI Status Preferd Eqp 1
      b_HmiStaWrn : Bool;   //  HMI Status equipment not ready
      b_HmiStaPref2 : Bool;   //  HMI Status Preferd Eqp 2
      b_HmiStaAreaMode : Bool;   //  HMI Status Area Mode
      b_HmiAlmAlm : Bool;   //  General Alarm
      b_HmiWrnEquip : Bool;   //  Equipment not available
      b_Eqp2First : Bool;   //  Toggle bit for Equipment selection; 1 = Eqp 2 first, 0 = eqp1 first
      b_Temp1 : Bool;   //  Equipments running for RE
      b_PrevTemp1 : Bool;   //  prev equipments running for RE
      b_Temp2 : Bool;   //  command manual toggle for RE
      b_PrevTemp2 : Bool;   //  prev command manual toggle for RE
      FB_UTIL_TON_Del_1 : "FB_UTIL_TON_Sec";   //  Timer block Strt to prevent simultainious Strting
      b_BlckStrt : Bool;   //  Block Strt to prevent Strting simultainous
      b_helpReady : Bool;   //  Help bit for status ready
      b_ReqAut : Bool;   //  Request automatic mode
      b_ReqMan : Bool;
      b_ReqDis : Bool;
   END_VAR

   VAR_TEMP 
      di_AUX : DInt;   //  auxiliary double word for calculation of state or alarm word to HMI
   END_VAR


BEGIN
	//not used// =========================================================================================================================  
	// Purpose: Reditech standard typical for controlling Pump Toggle manual automatic or semi-automatic
	// -------------------------------------------------------------------------------------------------------------------------
	// Date (dd MMM yyyy)   Developer                                   Version Comments/Reason for change
	// ..................   .........                                   ....... ..........................
	// 16 OCT 2018          Robin Cardinaels                               01      Initial (creation)
	// 15 Jan 2019          Robin Cardinaels                               02      Review
	// =========================================================================================================================
	// copy command bits from HMI and reset
	#b_HmiCmdModAut := #IOdi_HmiCmd.%X0;
	#b_HmiCmdModMan := #IOdi_HmiCmd.%X1;
	#b_HmiCmdRst := #IOdi_HmiCmd.%X3;
	
	
	#IOdi_HmiCmd := 0;
	
	// Copy of Function Command bits
	#b_HmiFcnCmdAuto := #IOdi_HmiFcnCmd.%X0;
	#b_HmiFcnCmdManual := #IOdi_HmiFcnCmd.%X2;
	#b_HmiCmdFrcEqp1First := #IOdi_HmiFcnCmd.%X4;
	#b_HmiCmdFrcEqp2First := #IOdi_HmiFcnCmd.%X5;
	#IOdi_HmiFcnCmd := 0;
	
	IF #b_HmiStaAreaMode THEN
	    #b_ReqAut := #IO_AreaCmd.Mode.Auto;
	    #b_ReqMan := #IO_AreaCmd.Mode.Man;
	    #b_ReqDis := #IO_AreaCmd.Mode.Dis;
	ELSE
	    #b_ReqAut := #b_HmiCmdModAut AND NOT #b_HmiStaAlm;
	    #b_ReqMan := #b_HmiCmdModMan OR (#b_HmiStaAlm AND NOT #b_HmiStaModDis);
	    #b_ReqDis := #b_HmiCmdModDis;
	END_IF;
	
	IF (#b_ReqAut AND NOT #b_ReqMan AND NOT #b_ReqDis) THEN
	    #b_HmiStaModAut := true;
	    #b_HmiStaModMan := false;
	    #b_HmiStaModDis := false;
	END_IF;
	IF (#b_ReqMan AND NOT #b_ReqAut AND NOT #b_ReqDis) THEN
	    #b_HmiStaModAut := false;
	    #b_HmiStaModMan := true;
	    #b_HmiStaModDis := false;
	END_IF;
	IF (#b_ReqDis AND NOT #b_ReqAut AND NOT #b_ReqMan) THEN
	    #b_HmiStaModAut := false;
	    #b_HmiStaModMan := false;
	    #b_HmiStaModDis := true;
	END_IF;
	
	// copy Function modes to status bits
	IF #b_HmiFcnCmdAuto THEN
	    #b_HmiStaFcnAuto := true;
	    #b_HmiStaFcnMan := false;
	END_IF;
	IF #b_HmiFcnCmdManual AND #Ib_EnMan THEN
	    #b_HmiStaFcnAuto := false;
	    #b_HmiStaFcnMan := true;
	END_IF;
	
	#b_PrevTemp1 := #b_Temp1;// temperoraty variable to get rising edge
	#b_Temp1 := (#Ob_ReqEqp1) OR (#Ob_ReqEqp2);
	
	// IF auto mode selected check operating hours every Time both motors are not running 
	IF (NOT #b_Temp1 AND #b_PrevTemp1) AND (#b_HmiStaFcnAuto AND NOT #b_HmiStaFcnMan) THEN
	    IF #Ib_CfgTogRun THEN //equipment with the lowest operating hours will Strt if Configurated
	        #b_Eqp2First := #Ii_Eqp2OpHours < #Ii_Eqp1OpHours; // reset toggle if equipment1 operating hours <= equipment2 operating hours
	    ELSE
	        #b_Eqp2First := NOT #b_Eqp2First;
	    END_IF;
	END_IF;
	#b_PrevTemp2 := #b_Temp2; // prev value of manual toggle command for RE
	#b_Temp2 := #Ib_ExtToggle; // manual toggle command
	//toggle equipments if manual toggle requested (hmi or external) and manual toggle configurated
	IF (#b_Temp2 AND NOT #b_PrevTemp2) AND (#b_HmiStaFcnAuto AND NOT #b_HmiStaFcnMan) THEN
	    #b_Eqp2First := NOT #b_Eqp2First;
	END_IF;
	
	// set equipment 2 actif if equipment 1 not available
	IF (#Ib_Eqp1Error OR #b_HmiCmdFrcEqp2First) AND NOT #Ib_Eqp2Error THEN
	    #b_Eqp2First := TRUE;
	END_IF;
	// set equipment 1 actif if equipment 2 not available
	IF (#Ib_Eqp2Error OR #b_HmiCmdFrcEqp1First) AND NOT #Ib_Eqp1Error THEN
	    #b_Eqp2First := FALSE;
	END_IF;
	
	// Set Output of FB
	// Set Output For equipment 1
	#Ob_ReqEqp1 := NOT #Ib_Eqp1Error AND (((#Ib_RequestEqp AND NOT #b_Eqp2First) AND (#b_BlckStrt OR #Ob_ReqEqp1) OR (#Ib_RequestCompEqp AND NOT #b_BlckStrt)) AND #Ib_EqpComp)
	OR (NOT #Ib_EqpComp AND #Ib_RequestEqp AND NOT #b_Eqp2First);
	
	//Set output for equipment 2
	#Ob_ReqEqp2 := NOT #Ib_Eqp2Error AND (((#Ib_RequestEqp AND #b_Eqp2First) AND (#b_BlckStrt OR #Ob_ReqEqp2) OR (#Ib_RequestCompEqp AND NOT #b_BlckStrt)) AND #Ib_EqpComp)
	OR (NOT #Ib_EqpComp AND #Ib_RequestEqp AND #b_Eqp2First);
	
	// timer to prevent simultanius Strting
	#FB_UTIL_TON_Del_1(Ii_tValue := #Ii_TBlckStrt,
	                   Ib_In := #Ob_ReqEqp1 OR #Ob_ReqEqp2,
	                   Ii_Base := 1,
	                   Ib_Hold := 0);
	
	// enable starting again
	#b_BlckStrt := NOT #FB_UTIL_TON_Del_1.Ob_Out;
	
	// HMI Status
	// Status Ready
	#b_helpReady := ((NOT #Ib_Eqp1Error OR NOT #Ib_Eqp2Error) AND NOT #Ib_EqpComp) OR //help bit ready if one equipment availeble in 1+1
	(NOT #Ib_Eqp1Error AND NOT #Ib_Eqp2Error); // or both equipments available
	#b_HmiStaReady := #b_helpReady AND NOT #b_HmiStaRunning;
	//Status Running
	#b_HmiStaRunning := #b_helpReady AND (#Ib_Eqp1Fb OR #Ib_Eqp2Fb);
	//Status OFF
	#b_HmiStaOff := NOT #b_HmiStaReady AND NOT #b_HmiStaRunning;
	// Show Prefferd Pump
	#b_HmiStaPref1 := NOT #b_Eqp2First;
	#b_HmiStaPref2 := #b_Eqp2First;
	//Wrning when motor not available
	#b_HmiWrnEquip := (#Ib_Eqp1Error OR #Ib_Eqp2Error) AND NOT #b_HmiAlmAlm;
	// status warning
	#b_HmiStaWrn := #b_HmiWrnEquip;
	#Ob_Wrn := #b_HmiWrnEquip;
	//Alarm when both pumps ar inavailable // auto reset if equipment is available
	#b_HmiAlmAlm := #Ib_Eqp1Error AND #Ib_Eqp2Error;
	
	// general alarm
	#b_HmiStaAlm := #b_HmiAlmAlm;
	#Ob_Alm := #b_HmiAlmAlm;
	
	// copy state bits into double word for HMI
	#di_AUX := 0;
	
	#di_AUX.%X0 := #b_HmiStaModAut;
	#di_AUX.%X1 := #b_HmiStaModMan;
	#di_AUX.%X2 := #b_HmiStaModDis;
	#di_AUX.%X8 := #b_HmiStaFcnAuto;
	
	#di_AUX.%X10 := #b_HmiStaFcnMan;
	#di_AUX.%X15 := #b_HmiStaOff;
	#di_AUX.%X16 := #b_HmiStaAlm;
	#di_AUX.%X21 := #b_HmiStaReady;
	#di_AUX.%X22 := #b_HmiStaRunning;
	#di_AUX.%X23 := #b_HmiStaPref1;
	#di_AUX.%X24 := #b_HmiStaWrn;
	#di_AUX.%X25 := #b_HmiStaPref2;
	#di_AUX.%X29 := #b_HmiStaAreaMode;
	
	#Odi_HmiSta := #di_AUX;
	
	// copy alarm bits into double word for HMI
	#di_AUX := 0;
	#di_AUX.%X0 := #b_HmiAlmAlm;
	#di_AUX.%X1 := #b_HmiWrnEquip;
	
	#Odi_HmiAlm := #di_AUX;
	#Oi_HmiAlm := DINT_TO_INT(#di_AUX);
	
	// Set feedback bits to area
	// #IO_AreaFb.Mode.Dis := #b_HmiStaModDis;
	// #IO_AreaFb.Mode.Man := #b_HmiStaModMan;
	// #IO_AreaFb.Mode.Auto := #b_HmiStaModAut;
	// #IO_AreaFb.Alm.Alm := #b_HmiStaAlm;
	// #IO_AreaFb.Alm.Wrn := #b_HmiStaWrn;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_UM_Mode"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
   VAR_INPUT 
      Ib_CmdRstAlm : Bool;
      Ib_CmdGenRelease : Bool;
      Ib_CmdRstRelease : Bool;
      Ib_CmdGenDis : Bool;
      Ib_AreaStopped : Bool;
      Ib_AreaCmdMode : Bool;
      Ib_SimForceOn : Bool;
      Ib_SimForceOff : Bool;
      Ib_DCSPermissive : Bool;
   END_VAR

   VAR_OUTPUT 
      Odi_HmiSta : DInt;
      Ou_AreaCmd : "UDT_AreaCmd";
      Ob_StaExecute : Bool;
      Ob_StaAlm : Bool;
      Ob_StaWrn : Bool;
      Ob_StaRstAlm : Bool;
      Ob_StaSim : Bool;
      Ou_CurrentMode : "UDT_PML_Mode";
   END_VAR

   VAR_IN_OUT 
      IOdi_HmiCmd : DInt;
      IOu_AreaFb : "UDT_AreaFb";
      Ib_CmdGenMan : Bool;
      IOw_DCSCmd : Word;
   END_VAR

   VAR 
      PML_ModeManager : "FB_PML_ModeManager";
      b_HmiCmdStart : Bool;
      b_HmiCmdModSimOn : Bool;
      b_HmiCmdModMan : Bool;
      b_HmiCmdModDis : Bool;
      b_HmiCmdModAuto : Bool;
      b_HmiCmdRstAlm : Bool;
      b_HmiCmdModSimOff : Bool;
      b_HmiCmdStop : Bool;
      b_StaRun : Bool;
      AreaFb : "UDT_AreaFb";
      AreaCmd : "UDT_AreaCmd";
      b_StaSim { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      StaAreaFb : "UDT_AreaFb";
      b_StaAlm_Lvl1 { S7_SetPoint := 'True'} : Bool;
      b_StaAlm_Lvl2 : Bool;
      b_StaAlm_Lvl3 : Bool;
      I_HmiSta : Word;
   END_VAR


BEGIN
	// =========================================================================================================================  
	// Purpose: Reditech standard typical for handling mode transition with the Reditech's standard PackML ModeManager
	// -------------------------------------------------------------------------------------------------------------------------
	// Date (dd MMM yyyy)   Developer                                   Version Comments/Reason for change
	// ..................   .........                                   ....... ..........................
	// 19 NOV 2018          Gijs van Hal                                01      Initial (creation)
	// 20 OCT 2020          Ivan Galhardoni                             02      Implemented manual mode external request input
	// 12 DEC 2020          Ivan Galhardoni                             03      Implemented alarm level animated signaling
	// =========================================================================================================================
	
	// Copy HMI commands
	#b_HmiCmdModMan := (#IOdi_HmiCmd.%X0 OR (#IOw_DCSCmd.%X1 AND #Ib_DCSPermissive)) OR #Ib_CmdGenMan AND NOT #Ib_CmdGenDis;
	#b_HmiCmdModDis := ((#IOdi_HmiCmd.%X1  OR (#IOw_DCSCmd.%X2 AND #Ib_DCSPermissive)) OR #Ib_CmdGenDis) AND NOT #Ib_CmdGenMan;
	#b_HmiCmdModAuto := (#IOdi_HmiCmd.%X2 OR (#IOw_DCSCmd.%X0 AND #Ib_DCSPermissive)) AND NOT #Ib_CmdGenDis;
	#b_HmiCmdModSimOn := #IOdi_HmiCmd.%X3;
	#b_HmiCmdModSimOff := #IOdi_HmiCmd.%X4;
	#b_HmiCmdStart := (#IOdi_HmiCmd.%X5 OR (#IOw_DCSCmd.%X3 AND #Ib_DCSPermissive)) AND #PML_ModeManager.Ou_ModeCurrent.Production;
	#b_HmiCmdStop := (#IOdi_HmiCmd.%X6 OR (#IOw_DCSCmd.%X4 AND #Ib_DCSPermissive)) OR #Ib_CmdGenDis;
	#b_HmiCmdRstAlm := #IOdi_HmiCmd.%X7;
	#IOdi_HmiCmd := 0;
	#IOw_DCSCmd := 0;
	
	
	// Mode change only possible if area is stopped
	IF #Ib_AreaStopped THEN
	    // Set Iu_CmdMode for ModeManager
	    #PML_ModeManager.Iu_CmdMode.Manual := #b_HmiCmdModMan;
	    #PML_ModeManager.Iu_CmdMode.Disabled := #b_HmiCmdModDis;
	    #PML_ModeManager.Iu_CmdMode.Production := #b_HmiCmdModAuto;
	    
	    // If Mode command is given, mode change request = true
	    IF (#b_HmiCmdModMan OR #b_HmiCmdModDis OR #b_HmiCmdModAuto) THEN
	        #PML_ModeManager.IOb_CmdModeChangeRequest := TRUE;
	    ELSE
	        #PML_ModeManager.IOb_CmdModeChangeRequest := FALSE;
	    END_IF;
	    
	END_IF;
	
	// Current state
	IF #b_StaRun THEN
	    #PML_ModeManager.Idi_StateCurrent := 6; // Execute State
	ELSE
	    #PML_ModeManager.Idi_StateCurrent := 2; // Stopped State
	END_IF;
	
	#PML_ModeManager();
	
	// If Cmd Simulation mode
	IF (#b_HmiCmdModSimOn) THEN
	    #b_StaSim := TRUE;
	ELSIF (#b_HmiCmdModSimOff) THEN
	    #b_StaSim := FALSE;
	END_IF;
	
	// If start and stop area
	IF (#b_HmiCmdStart) THEN
	    #b_StaRun := TRUE;
	END_IF;
	IF (#b_HmiCmdStop OR #Ib_CmdRstRelease OR #Ib_CmdGenMan) THEN
	    #b_StaRun := FALSE;
	END_IF;
	
	
	// Write outputs
	#Ob_StaExecute := #Ib_CmdGenRelease AND #b_StaRun;
	#Ob_StaAlm := #IOu_AreaFb.Alm.Alm;
	#Ob_StaWrn := #IOu_AreaFb.Alm.Wrn;
	#Ob_StaRstAlm := #Ib_CmdRstAlm OR #b_HmiCmdRstAlm;
	#Ob_StaSim := #b_StaSim;
	#b_StaAlm_Lvl1 := #IOu_AreaFb.Alm.Alm_Lvl1;
	#b_StaAlm_Lvl2 := #IOu_AreaFb.Alm.Alm_Lvl2;
	#b_StaAlm_Lvl3 := #IOu_AreaFb.Alm.Alm_Lvl3;
	
	// Area commands
	#Ou_AreaCmd.Alm.Rst := #Ib_CmdRstAlm OR #b_HmiCmdRstAlm;
	#Ou_AreaCmd.Mode.Man := #PML_ModeManager.Ou_ModeCurrent.Manual;
	#Ou_AreaCmd.Mode.Dis := #PML_ModeManager.Ou_ModeCurrent.Disabled;
	#Ou_AreaCmd.Mode.Auto := #PML_ModeManager.Ou_ModeCurrent.Production;
	#Ou_AreaCmd.Sim.ForceOff := #Ib_SimForceOff;
	#Ou_AreaCmd.Sim.ForceOn := #Ib_SimForceOn;
	#Ou_AreaCmd.Mode.AreaMode := #Ib_AreaCmdMode;
	
	// Write Current Mode UDT to output.
	#Ou_CurrentMode.Production := #PML_ModeManager.Ou_ModeCurrent.Production;
	#Ou_CurrentMode.Manual := #PML_ModeManager.Ou_ModeCurrent.Manual;
	#Ou_CurrentMode.Disabled := #PML_ModeManager.Ou_ModeCurrent.Disabled;
	
	// Status Area feedback
	#StaAreaFb.Alm.Alm := #IOu_AreaFb.Alm.Alm;
	#StaAreaFb.Alm.Wrn := #IOu_AreaFb.Alm.Wrn;
	#StaAreaFb.Alm.New := #IOu_AreaFb.Alm.New;
	#StaAreaFb.Alm.StopArea := #IOu_AreaFb.Alm.StopArea;
	
	// Reset Area feedback
	#IOu_AreaFb.Alm.Alm := FALSE;
	#IOu_AreaFb.Alm.Wrn := FALSE;
	#IOu_AreaFb.Alm.New := FALSE;
	#IOu_AreaFb.Alm.StopArea := FALSE;
	#IOu_AreaFb.Alm.Alm_Lvl1 := FALSE;
	#IOu_AreaFb.Alm.Alm_Lvl2 := FALSE;
	#IOu_AreaFb.Alm.Alm_Lvl3 := FALSE;
	
	
	// Copy state bits into double word for HMI
	#Odi_HmiSta.%X0 := #PML_ModeManager.Ou_ModeCurrent.Manual;
	#Odi_HmiSta.%X1 := #PML_ModeManager.Ou_ModeCurrent.Disabled;
	#Odi_HmiSta.%X2 := #PML_ModeManager.Ou_ModeCurrent.Production;
	#Odi_HmiSta.%X3 := #Ob_StaSim;
	#Odi_HmiSta.%X4 := #Ob_StaAlm;
	#Odi_HmiSta.%X5 := #Ob_StaWrn;
	#Odi_HmiSta.%X6 := #b_StaRun;
	#Odi_HmiSta.%X7 := #Ib_AreaStopped;
	#Odi_HmiSta.%X8 := #b_StaAlm_Lvl1;    //Animated Lvl1 area alarm status
	#Odi_HmiSta.%X9 := #b_StaAlm_Lvl2;    //Animated Lvl2 area alarm status
	#Odi_HmiSta.%X10 := #b_StaAlm_Lvl3;   //Animated Lvl3 area alarm status
	
	
	// Copy state bits into word for HMI
	#I_HmiSta.%X0 := #PML_ModeManager.Ou_ModeCurrent.Production;
	#I_HmiSta.%X1 := #PML_ModeManager.Ou_ModeCurrent.Manual;
	#I_HmiSta.%X2 := #PML_ModeManager.Ou_ModeCurrent.Disabled;
	#I_HmiSta.%X3 := #b_StaRun;
	#I_HmiSta.%X4 := NOT #b_StaRun;
	#I_HmiSta.%X7 := #Ib_AreaStopped;
	#I_HmiSta.%X8 := #Ob_StaAlm;    
	#I_HmiSta.%X9 := #Ob_StaWrn;    
	  
	
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_CM_AXV"
TITLE = Analog valve
{ S7_Optimized_Access := 'FALSE' }
AUTHOR : Reditech
FAMILY : Typical
VERSION : 0.0
//Reditech standard typical for controlling an analog valve
   VAR_INPUT 
      Ib_FbPosOpn : Bool := FALSE;   //  feedback position open (failsafe : 0=open)
      Ib_FbPosCls : Bool := FALSE;   //  feedback position closed (failsafe : 0=closed)
      Ir_ActPos : Real;   //  Actual valve position (measurement)
      Ir_ParAutSp : Real;   //  automatic setpoint
      Ir_ParMaxPos : Real := 100.0;   //  Maximum position value
      Ir_ParMinPos : Real := 0.0;   //  Minimum position value
      Ir_ParCtlDev : Real := 1.0;   //  Control deviation (for digital output and feedback OK)
      Ir_ParSafPos : Real;   //  Safety position
      Ir_ParMaxRaw : Real;   //  Max value for analogue output mode
      Ir_ParMinRaw : Real;   //  Min value for analogue output mode
      Ii_ParTO : Int := 5;   //  time out value for feedback monitoring
      Iby_Saf : Byte := 16#00;   //  8 safety bits : 1=error
      Iby_IlOn : Byte;   //  8 interlock bits : 1 prevents Pos1/opening
      Iby_IlOff { ExternalVisible := 'False'} : Byte;   //  8 interlock bits : 1 prevents Pos0/closing
      Ib_Pls1S : Bool;
      Ib_DisAlmWrn : Bool;
      Iw_Cfg : Word := 16#0001;   //  .0=analog pos present / .1=digital pos present
   END_VAR

   VAR_OUTPUT 
      Or_SpOut : Real;   //  Control output
      Ow_SpRaw : Word;   //  Control output recalculated for analog output node
      Ob_Opn : Bool;   //  control output open
      Ob_Cls : Bool;   //  control output close
      Ob_PosOk : Bool;   //  Position reached
      Ob_Alm : Bool;   //  general alarm
      Ob_StaOpn : Bool;   //  Status in position 1
      Ob_StaCls : Bool;   //  Status in position 0
      Or_StaPos : Real;
      Odi_HmiSta : DInt;   //  State bits for HMI
      Oi_HmiAlm : Int;
      Odi_HmiAlm : DInt;   //  Alarm bit for HMI
   END_VAR

   VAR_IN_OUT 
      IOr_ManSP : Real;   //  manual setpoint
      IOr_SimPos : Real;   //  Simulated position
      IOdi_HmiCmd : DInt;   //  Command bits from HMI
      IO_AreaCmd : "UDT_AreaCmd";   //  Command bits from area
      IO_AreaFb : "UDT_AreaFb";   //  Feedback bits to area
   END_VAR

   VAR 
      i_TmrFbPos : Int;   //  timer feedback control
      b_HmiCmdModAut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  command change mode to AUTO
      b_HmiCmdModMan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  command change mode to MANUAL
      b_HmiCmdModDis { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  command change mode to DISABLED
      b_HmiCmdSim { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  toggle simulation mode
      b_HmiCmdRst { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  reset alarms
      b_StaModAut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  state AUTOMATIC
      b_StaModMan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool := TRUE;   //  state MANUAL
      b_StaModDis { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  state DISABLED
      b_StaSim { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  state simulation ON
      b_StaIlOff { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  state interlock OFF : 1 = interlocked (prevents closing)
      b_StaIlOn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  state interlock ON : 1 = interlocked (prevents opening)
      b_StaSaf { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  state safety : 1 = error (valve to safety position)
      b_ReqOpn { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  output command open
      b_ReqCls { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  output command close
      b_StaPosOk { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  position (setpoint) reached
      b_StaAlm { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  general alarm
      b_CfgAnaPosPres { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  configuration : analog position feedback present
      b_CfgDigPosPres { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  configuration : digital limit positions present (min and max)
      b_CfgHldMod { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      b_CfgDisableSim { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      b_CfgStopArea { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      b_AlmToFb { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  alarm time out feedback
      b_AlmFbInc { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  alarm inconsistent feedbacks (both together)
      b_AlmIncIl { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  alarm inconsistent interlocks (both together)
      b_ReqAut { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  automatic mode requested
      b_ReqMan { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  manual mode requested
      b_ReqDis { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  disabled mode requested
      b_TFbPos { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;   //  tmer finished, feedback monitoring Pos1
      b_SpChange { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Bool;
      r_SpSel { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;   //  selected setpoint
      r_SpPrev { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;
      r_DevMax { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;
      r_DevMin { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;
      r_FrzVal { ExternalAccessible := 'False'; ExternalVisible := 'False'; ExternalWritable := 'False'} : Real;
      b_TStart : Bool;
      b_Tsim : Bool;
      FB_UTIL_TON_Instance_AXV_TEST : "FB_UTIL_TON_Sec";
      FB_UTIL_TON_Instance : "FB_UTIL_TON_Sec";
      i_TSim : Int;
      b_PrevTSim : Bool;
      r_ReqSP : Real;
      r_DevClsMaxEP : Real;
      r_DevClsMinEP : Real;
      r_DevOpnMaxEP : Real;
      r_DevOpnMinEP : Real;
      b_AlmIncInput : Bool;
      b_AlmOutOfBounds : Bool;
      b_AlmFbEP : Bool;
      b_CondOutOfBounds : Bool;
      b_DisAlmWrn : Bool;
      b_dummy : Bool;
      i_dummy : Int;
      b_StaAlmNew : Bool;
      b_NoAlm : Bool;
      i_AlmAck : Int;
      b_DisAlmWrn_1 : Bool;
      b_RstAlm : Bool;
      b_AutoMan_SP : Bool;   // HMI Selection for Automatic or Manual SetPoint 0->Man / 1->Auto
      I_HmiSta : Word;
      i_Category : Int := 1;   // Device alarm category setting
   END_VAR

   VAR_TEMP 
      di_AUX : DInt;   //  auxiliary double word for calculation of state or alarm word to HMI
   END_VAR


BEGIN
	// =============================================================================================================================  
	// Purpose: Reditech standard typical FOR controlling an analog valve
	// -----------------------------------------------------------------------------------------------------------------------------
	// Date (dd MMM yyyy) Developer                                   Version Comments/Reason FOR change
	// .................. .........                                   ....... ..........................
	// 18 Dec 2018        Bram Verheyen                               09.0    Full review
	// 30 Jan 2019        Matthias De Staelen                         09.1    Outputs can be high in simulation mode
	// =============================================================================================================================
	
	//============================================================================================
	#b_CfgAnaPosPres := #Iw_Cfg.%X0;
	#b_CfgDigPosPres := #Iw_Cfg.%X1;
	#b_CfgHldMod := #Iw_Cfg.%X2;
	#b_CfgDisableSim := #Iw_Cfg.%X10;
	#b_CfgStopArea := #Iw_Cfg.%X11;
	
	//============================================================================================
	#b_DisAlmWrn := #Ib_DisAlmWrn OR #IO_AreaCmd.Alm.Dis OR #b_StaModDis;
	
	//============================================================================================
	#b_StaSaf := (#Iby_Saf <> 0);
	#b_StaIlOn := (#Iby_IlOn <> 0);
	#b_StaIlOff := (#Iby_IlOff <> 0);
	
	//============================================================================================
	#b_HmiCmdModAut := #IOdi_HmiCmd.%X0;
	#b_HmiCmdModMan := #IOdi_HmiCmd.%X1;
	#b_HmiCmdModDis := #IOdi_HmiCmd.%X2;
	#b_HmiCmdSim := #IOdi_HmiCmd.%X3;
	#b_HmiCmdRst := #IOdi_HmiCmd.%X4;
	#IOdi_HmiCmd := 0;
	
	//============================================================================================
	IF #IO_AreaCmd.Mode.AreaMode THEN
	    #b_ReqAut := #IO_AreaCmd.Mode.Auto;
	    #b_ReqMan := #IO_AreaCmd.Mode.Man;
	    #b_ReqDis := #IO_AreaCmd.Mode.Dis;
	ELSE
	    IF #b_CfgHldMod THEN
	        #b_ReqAut := #b_HmiCmdModAut;
	        #b_ReqMan := #b_HmiCmdModMan;
	        #b_ReqDis := #b_HmiCmdModDis;
	    ELSE
	        #b_ReqAut := #b_HmiCmdModAut AND NOT #b_StaAlm AND NOT #b_StaSaf;
	        #b_ReqMan := #b_HmiCmdModMan OR ((#b_StaAlm OR #b_StaSaf) AND NOT #b_StaModDis);
	        #b_ReqDis := #b_HmiCmdModDis;
	    END_IF;
	END_IF;
	IF (#b_ReqAut AND NOT #b_ReqMan AND NOT #b_ReqDis) THEN
	    #b_StaModAut := true;
	    #b_StaModMan := false;
	    #b_StaModDis := false;
	END_IF;
	IF (#b_ReqMan AND NOT #b_ReqAut AND NOT #b_ReqDis) THEN
	    #b_StaModAut := false;
	    #b_StaModMan := true;
	    #b_StaModDis := false;
	END_IF;
	IF (#b_ReqDis AND NOT #b_ReqMan AND NOT #b_ReqAut) THEN
	    #b_StaModAut := false;
	    #b_StaModMan := false;
	    #b_StaModDis := true;
	END_IF;
	
	//============================================================================================
	IF #IO_AreaCmd.Sim.ForceOn OR (#b_HmiCmdSim AND NOT #b_StaSim AND NOT #IO_AreaCmd.Sim.ForceOn AND NOT #IO_AreaCmd.Sim.ForceOff) THEN
	    #b_StaSim := true;
	    #b_HmiCmdSim := false; // reset of command necessary, else simulation will always be reset immediately by following instructions
	END_IF;
	IF #IO_AreaCmd.Sim.ForceOff OR (#b_HmiCmdSim AND #b_StaSim AND NOT #IO_AreaCmd.Sim.ForceOn AND NOT #IO_AreaCmd.Sim.ForceOff) THEN
	    #b_StaSim := false;
	    #b_HmiCmdSim := false;
	END_IF;
	
	//============================================================================================
	// automatic feedback simulation
	#r_DevMax := #r_SpSel + #Ir_ParCtlDev;
	#r_DevMin := #r_SpSel - #Ir_ParCtlDev;
	IF #b_StaSim AND "Clock_10Hz" THEN
	    IF (#IOr_SimPos <= #r_DevMin) THEN
	        #IOr_SimPos := #IOr_SimPos + #Ir_ParCtlDev;
	    END_IF;
	    IF (#IOr_SimPos >= #r_DevMax) THEN
	        #IOr_SimPos := #IOr_SimPos - #Ir_ParCtlDev;
	    END_IF;
	END_IF;
	
	// Select valve position
	IF #b_StaSim THEN
	    #Or_StaPos := #IOr_SimPos;
	END_IF;
	IF NOT #b_StaSim AND #b_CfgAnaPosPres THEN
	    #Or_StaPos := #Ir_ActPos;
	END_IF;
	IF NOT #b_StaSim AND NOT #b_CfgAnaPosPres AND #b_CfgDigPosPres AND #Ob_StaOpn THEN
	    #Or_StaPos := #Ir_ParMaxPos;
	END_IF;
	IF NOT #b_StaSim AND NOT #b_CfgAnaPosPres AND #b_CfgDigPosPres AND #Ob_StaCls THEN
	    #Or_StaPos := #Ir_ParMinPos;
	END_IF;
	IF NOT #b_StaSim AND NOT #b_CfgAnaPosPres AND NOT #b_CfgDigPosPres THEN
	    #Or_StaPos := #Or_SpOut;
	END_IF;
	
	//============================================================================================
	// Digital feedback, selection simulation or real time
	#Ob_StaOpn := (NOT #b_StaSim AND (#b_CfgDigPosPres AND #Ib_FbPosOpn))
	OR (NOT #b_StaSim AND (NOT #b_CfgDigPosPres AND (#Or_StaPos >= #r_DevOpnMinEP)))
	OR (#b_StaSim AND (#Or_StaPos > #r_DevClsMaxEP));
	
	#Ob_StaCls := (NOT #b_StaSim AND (#b_CfgDigPosPres AND #Ib_FbPosCls))
	OR (NOT #b_StaSim AND (NOT #b_CfgDigPosPres AND (#Or_StaPos <= #r_DevClsMaxEP)))
	OR (#b_StaSim AND (#Or_StaPos <= #r_DevClsMaxEP));
	
	// If the valve position is between 1% and 100%, shows color purple         
	IF (#Or_StaPos > 1.0) AND (#Or_StaPos < 100.0)
	THEN
	    #Odi_HmiSta.%X8 := TRUE;
	ELSE
	    #Odi_HmiSta.%X8 := FALSE;
	END_IF;
	
	// Setpoint feedback check
	#b_StaPosOk := (NOT #b_CfgAnaPosPres) OR
	(#b_CfgAnaPosPres AND (#Ir_ActPos >= (#Or_SpOut - #Ir_ParCtlDev)) AND (#Ir_ActPos <= (#Or_SpOut + #Ir_ParCtlDev)));
	#Ob_PosOk := #b_StaPosOk AND NOT #b_StaAlm;
	
	//============================================================================================
	#b_SpChange := (#r_SpSel <> #r_SpPrev);
	#r_SpPrev := #r_SpSel;
	
	//============================================================================================
	(*lower and higher deviation values from the endpoint*)
	#r_DevClsMaxEP := #Ir_ParMinPos + #Ir_ParCtlDev;
	#r_DevClsMinEP := #Ir_ParMinPos - #Ir_ParCtlDev;
	#r_DevOpnMaxEP := #Ir_ParMaxPos + #Ir_ParCtlDev;
	#r_DevOpnMinEP := #Ir_ParMaxPos - #Ir_ParCtlDev;
	
	//============================================================================================
	#b_NoAlm := false;
	#b_RstAlm := #b_HmiCmdRst OR #IO_AreaCmd.Alm.Rst;
	"FC_UTIL_AlmAck"(Ib_CmdAck := #b_RstAlm,
	                 Oi_StaAlm => #i_dummy,
	                 Ob_StaAlm => #b_dummy,
	                 Ob_StaNewAlm => #b_StaAlmNew,
	                 IO_Alm0 := #b_AlmToFb,
	                 IO_Alm1 := #b_AlmFbInc,
	                 IO_Alm2 := #b_AlmIncIl,
	                 IO_Alm3 := #b_AlmOutOfBounds,
	                 IO_Alm4 := #b_AlmFbEP,
	                 IO_Alm5 := #b_AlmIncInput,
	                 IO_Alm6 := #b_NoAlm,
	                 IO_Alm7 := #b_NoAlm,
	                 IO_Alm8 := #b_NoAlm,
	                 IO_Alm9 := #b_NoAlm,
	                 IO_Alm10 := #b_NoAlm,
	                 IO_Alm11 := #b_NoAlm,
	                 IO_Alm12 := #b_NoAlm,
	                 IO_Alm13 := #b_NoAlm,
	                 IO_Alm14 := #b_NoAlm,
	                 IO_Alm15 := #b_NoAlm,
	                 IOi_StaAck := #i_AlmAck);
	
	
	//============================================================================================
	IF #Ii_ParTO > 0 THEN  // only when time value > 0
	    #FB_UTIL_TON_Instance_AXV_TEST(Ib_In := (#b_CfgAnaPosPres AND NOT #b_StaPosOk AND NOT #b_SpChange AND NOT #b_StaSim),
	                                   Ii_Base := 1,
	                                   Ib_Hold := 0,
	                                   Ii_tValue := #Ii_ParTO,
	                                   Oi_tmrValue => #i_TmrFbPos,
	                                   Ob_Out => #b_TFbPos);
	END_IF;
	
	IF (#b_TFbPos AND (#Ii_ParTO > 0))
	    AND NOT #b_DisAlmWrn THEN
	    #b_AlmToFb := true;
	END_IF;
	
	//============================================================================================
	IF (#r_ReqSP > #Ir_ParMaxPos
	    OR #r_ReqSP < #Ir_ParMinPos
	    OR (#Ir_ParSafPos > 0 AND (#Ir_ParSafPos > #Ir_ParMaxPos OR #Ir_ParSafPos < #Ir_ParMinPos)))
	    AND NOT #b_DisAlmWrn THEN
	    #b_AlmOutOfBounds := true;
	END_IF;
	
	//============================================================================================
	IF ((#Ir_ActPos > #r_DevOpnMaxEP OR #Ir_ActPos < #r_DevClsMinEP) AND #b_CfgAnaPosPres)
	    AND NOT #b_DisAlmWrn THEN
	    #b_AlmIncInput := 1;
	END_IF;
	
	//============================================================================================
	IF (#Ob_StaOpn AND #Ob_StaCls)
	    AND NOT #b_DisAlmWrn THEN
	    #b_AlmFbInc := 1;
	END_IF;
	
	//============================================================================================
	IF (#b_CfgAnaPosPres
	    AND #b_CfgDigPosPres
	    AND ((#Ib_FbPosCls AND #Ir_ActPos > #r_DevClsMaxEP) OR (#Ib_FbPosOpn AND #Ir_ActPos < #r_DevOpnMinEP)))
	    AND NOT #b_DisAlmWrn THEN
	    #b_AlmFbEP := true;
	END_IF;
	
	//============================================================================================
	IF (#b_StaIlOn AND #b_StaIlOff) AND NOT #b_DisAlmWrn THEN
	    #b_AlmIncIl := true;
	END_IF;
	IF NOT (#b_StaIlOn AND #b_StaIlOff) THEN
	    #b_AlmIncIl := false;
	END_IF;
	
	//============================================================================================
	#b_StaAlm := #b_AlmOutOfBounds OR #b_AlmToFb OR #b_StaSaf OR #b_AlmFbInc OR #b_AlmIncIl OR #b_AlmIncInput OR #b_AlmFbEP OR (#Iby_IlOn>0) OR (#Iby_IlOff>0);
	#Ob_Alm := #b_StaAlm;
	
	//============================================================================================
	IF #b_StaModAut THEN
	    #r_ReqSP := #Ir_ParAutSp;
	END_IF;
	
	//============================================================================================
	IF #b_StaModMan THEN
	    #r_ReqSP := #IOr_ManSP;
	END_IF;
	
	//============================================================================================
	IF #b_StaModAut OR #b_StaModMan THEN
	    (*go to min pos*)
	    IF (#b_StaIlOn AND #b_CfgAnaPosPres) THEN
	        #r_SpSel := #Ir_ParMinPos;
	        #IOr_ManSP := #Ir_ParMinPos;
	        
	        (*hold condition*)
	    ELSIF (#b_StaIlOff AND #b_CfgAnaPosPres) THEN
	        #r_SpSel := #r_FrzVal;
	        #IOr_ManSP := #r_FrzVal;
	        
	        (*follows setpoint as usual*)
	    ELSE
	        #r_SpSel := #r_ReqSP;
	    END_IF;
	END_IF;
	
	IF (#b_StaSaf OR #b_StaAlm) THEN
	    IF #Ir_ParSafPos > 0 THEN
	        #r_SpSel := #Ir_ParSafPos;
	    ELSE
	        #r_SpSel := #r_FrzVal;
	    END_IF;
	ELSIF (#b_AlmToFb OR #b_AlmIncInput) THEN
	    #r_SpSel := #r_FrzVal;
	END_IF;
	
	IF #b_StaIlOn THEN
	    #r_SpSel := #Ir_ParMinPos;
	END_IF;
	
	IF #b_StaModDis THEN
	    #r_SpSel := 0.0;
	    #IOr_ManSP := 0.0;
	END_IF;
	
	//============================================================================================
	#b_ReqOpn := (#Or_StaPos < #r_DevMin) AND NOT #b_StaAlm AND NOT #b_StaIlOn AND NOT #b_StaModDis AND NOT #Ob_StaOpn;
	#b_ReqCls := (#Or_StaPos > #r_DevMax) AND NOT #b_StaAlm AND NOT #b_StaIlOff AND NOT #b_StaModDis AND NOT #Ob_StaCls;
	
	//============================================================================================
	// Output position
	#Or_SpOut := #r_SpSel;
	#Ob_Opn := #b_ReqOpn;
	#Ob_Cls := #b_ReqCls;
	
	// recalculate output to word value for analog output node
	IF ((#Ir_ParMaxPos - #Ir_ParMinPos) > 0.0) THEN  // check if division by positive number
	    #Ow_SpRaw := INT_TO_WORD(IN := (REAL_TO_INT(IN := ((((#r_SpSel - #Ir_ParMinPos) / (#Ir_ParMaxPos - #Ir_ParMinPos)) * (#Ir_ParMaxRaw - #Ir_ParMinRaw)) + #Ir_ParMinRaw))));
	ELSE
	    #Ow_SpRaw := 0;
	END_IF;
	
	//============================================================================================
	IF NOT #b_AlmToFb
	    AND NOT #b_AlmFbInc
	    AND NOT #b_AlmIncIl
	    AND NOT #b_AlmOutOfBounds
	    AND NOT #b_AlmFbEP
	    AND NOT #b_AlmIncInput
	    AND NOT #b_StaIlOff THEN
	    #r_FrzVal := #Ir_ActPos;
	END_IF;
	
	//============================================================================================
	#Odi_HmiSta.%X0 := #b_StaModAut;
	#Odi_HmiSta.%X1 := #b_StaModMan;
	#Odi_HmiSta.%X2 := #b_StaModDis;
	#Odi_HmiSta.%X3 := #b_StaSim;
	#Odi_HmiSta.%X4 := #b_StaIlOff;
	#Odi_HmiSta.%X5 := #b_StaIlOn;
	#Odi_HmiSta.%X6 := #b_StaSaf;
	#Odi_HmiSta.%X7 := #b_StaSim;
	#Odi_HmiSta.%X16 := #b_ReqOpn;
	#Odi_HmiSta.%X17 := #b_ReqCls;
	#Odi_HmiSta.%X18 := #b_StaPosOk;
	#Odi_HmiSta.%X19 := #Ob_StaOpn;
	#Odi_HmiSta.%X20 := #Ob_StaCls;
	#Odi_HmiSta.%X21 := #b_StaAlm;
	#Odi_HmiSta.%X24 := #b_CfgAnaPosPres;
	#Odi_HmiSta.%X25 := #b_CfgDigPosPres;
	#Odi_HmiSta.%X26 := #b_CfgHldMod;
	#Odi_HmiSta.%X28 := #IO_AreaCmd.Mode.AreaMode;
	
	#I_HmiSta.%X0 := #b_StaModAut;
	#I_HmiSta.%X1 := #b_StaModMan;
	#I_HmiSta.%X2 := #b_StaModDis;
	#I_HmiSta.%X3 := #b_StaSim;
	
	IF #Or_StaPos = 100.0 THEN
	    #I_HmiSta.%X4 := TRUE;
	ELSE
	    #I_HmiSta.%X4 := FALSE;
	END_IF;
	
	#I_HmiSta.%X5 := #Ob_StaCls;
	#I_HmiSta.%X6 := #Odi_HmiSta.%X8; //Between 0% and 100%
	#I_HmiSta.%X7 := #b_StaAlm;
	
	//============================================================================================
	#di_AUX := 0;
	#di_AUX.%X0 := #b_AlmToFb;
	#di_AUX.%X1 := #b_AlmFbInc;
	#di_AUX.%X2 := #b_AlmIncIl;
	#di_AUX.%X3 := #b_AlmOutOfBounds;
	#di_AUX.%X4 := #b_AlmFbEP;
	#di_AUX.%X5 := #b_AlmIncInput;
	#di_AUX.%X8 := #Iby_IlOff.%X0;
	#di_AUX.%X9 := #Iby_IlOff.%X1;
	#di_AUX.%X10 := #Iby_IlOff.%X2;
	#di_AUX.%X11 := #Iby_IlOff.%X3;
	#di_AUX.%X12 := #Iby_IlOff.%X4;
	#di_AUX.%X13 := #Iby_IlOff.%X5;
	#di_AUX.%X14 := #Iby_IlOff.%X6;
	#di_AUX.%X15 := #Iby_IlOff.%X7;
	#di_AUX.%X16 := #Iby_IlOn.%X0;
	#di_AUX.%X17 := #Iby_IlOn.%X1;
	#di_AUX.%X18 := #Iby_IlOn.%X2;
	#di_AUX.%X19 := #Iby_IlOn.%X3;
	#di_AUX.%X20 := #Iby_IlOn.%X4;
	#di_AUX.%X21 := #Iby_IlOn.%X5;
	#di_AUX.%X22 := #Iby_IlOn.%X6;
	#di_AUX.%X23 := #Iby_IlOn.%X7;
	#di_AUX.%X24 := #Iby_Saf.%X0;
	#di_AUX.%X25 := #Iby_Saf.%X1;
	#di_AUX.%X26 := #Iby_Saf.%X2;
	#di_AUX.%X27 := #Iby_Saf.%X3;
	#di_AUX.%X28 := #Iby_Saf.%X4;
	#di_AUX.%X29 := #Iby_Saf.%X5;
	#di_AUX.%X30 := #Iby_Saf.%X6;
	#di_AUX.%X31 := #Iby_Saf.%X7;
	#Odi_HmiAlm := #di_AUX;
	
	//============================================================================================
	#di_AUX := 0;
	#di_AUX.%X0 := #b_AlmToFb;
	#di_AUX.%X1 := #b_AlmFbInc;
	#di_AUX.%X2 := #b_AlmIncIl;
	#di_AUX.%X3 := #b_AlmOutOfBounds;
	#di_AUX.%X4 := #b_AlmFbEP;
	#di_AUX.%X5 := #b_AlmIncInput;
	#Oi_HmiAlm := DINT_TO_INT(#di_AUX);
	
	//============================================================================================
	IF #b_StaModDis THEN
	    #IO_AreaFb.Mode.Dis := TRUE;
	END_IF;
	IF #b_StaModMan THEN
	    #IO_AreaFb.Mode.Man := TRUE;
	END_IF;
	IF #b_StaModAut THEN
	    #IO_AreaFb.Mode.Auto := TRUE;
	END_IF;
	IF #b_StaAlm THEN
	    #IO_AreaFb.Alm.Alm := TRUE;
	END_IF;
	IF #b_StaAlmNew THEN
	    #IO_AreaFb.Alm.New := TRUE;
	END_IF;
	IF #b_StaSim THEN
	    #IO_AreaFb.Sim.Sim := TRUE;
	END_IF;
	IF #b_StaAlm AND #b_CfgStopArea THEN
	    #IO_AreaFb.Alm.StopArea := TRUE;
	END_IF;
	
	//Generating alarm category feedback
	IF #i_Category = 1 AND #b_StaAlm THEN
	    #IO_AreaFb.Alm.Alm_Lvl1 := TRUE;
	END_IF;
	
	IF #i_Category = 2 AND #b_StaAlm THEN
	    #IO_AreaFb.Alm.Alm_Lvl2 := TRUE;
	END_IF;
	
	IF #i_Category = 3 AND #b_StaAlm THEN
	    #IO_AreaFb.Alm.Alm_Lvl3 := TRUE;
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_EM_Lvl_3Eqp"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
   VAR_INPUT 
      Ib_RequestEqp { ExternalVisible := 'False'} : Bool;   //  Request equipment Command
      Ib_LvlOff_FirstEqp : Bool;   //  Level switch low low
      Ib_LvlOff_SecondEqp : Bool;   //  Level switch low
      Ib_LvlOff_ThirdEqp : Bool;
      Ib_LvlOn_FirstEqp : Bool;   //  Level switch high
      Ib_LvlOn_SecondEqp : Bool;   //  Level switch High High
      Ib_LvlOn_ThirdEqp : Bool;
      Ib_NrEqp : Int;   //  Number of equipment used at the same time, 0 = 1 eqp, 1 = 2 eqp
   END_VAR

   VAR_OUTPUT 
      Ob_ReqFirstEqp : Bool;   //  Request first equipment
      Ob_ReqSecondEqp : Bool;   //  Request second equipment
      Ob_ReqThirdEqp : Bool;
   END_VAR

   VAR_IN_OUT 
      IO_AreaCmd : "UDT_AreaCmd";   //  Command bits from area
      IO_AreaFb : "UDT_AreaFb";   //  Feedback bits to area
   END_VAR

   VAR 
      b_FirstEqpReq : Bool;   //  Request to Equipment 1
      b_SecondEqpReq : Bool;   //  Request to Equipment 2
      b_ThirdEqpReq : Bool;
      b_ReqAut : Bool;   //  Request automatic mode
      b_ReqMan : Bool;
      b_ReqDis : Bool;
   END_VAR


BEGIN
	//not used// =========================================================================================================================  
	// Purpose: Reditech standard typical for controlling Pump Toggle manual automatic or semi-automatic
	// -------------------------------------------------------------------------------------------------------------------------
	// Date (dd MMM yyyy)   Developer                                   Version Comments/Reason for change
	// ..................   .........                                   ....... ..........................
	// 16 OCT 2018          Robin Cardinaels                               01      Initial (creation)
	// 31 JUL 2020          Ivan Galhardoni                                02      Implemented third Eqp for control
	// =========================================================================================================================
	// copy command bits from HMI and reset
	
	#b_ReqAut := #IO_AreaCmd.Mode.Auto;
	#b_ReqMan := #IO_AreaCmd.Mode.Man;
	#b_ReqDis := #IO_AreaCmd.Mode.Dis;
	
	IF NOT #b_ReqAut THEN
	    #b_FirstEqpReq := #b_SecondEqpReq := #b_ThirdEqpReq := false;
	ELSE
	    IF #Ib_LvlOn_FirstEqp THEN
	        #b_FirstEqpReq := TRUE;
	    END_IF;
	    IF #Ib_LvlOff_FirstEqp THEN
	        #b_FirstEqpReq := FALSE;
	    END_IF;
	    
	    IF #Ib_NrEqp >= 2 THEN
	        // setting control bits for anaog and digital control.
	        IF #Ib_LvlOn_SecondEqp THEN
	            #b_SecondEqpReq := TRUE;
	        END_IF;
	        IF #Ib_LvlOff_SecondEqp THEN
	            #b_SecondEqpReq := FALSE;
	        END_IF;
	    ELSE
	        #b_SecondEqpReq := false;
	    END_IF;
	    
	    IF #Ib_NrEqp = 3 THEN
	        // setting control bits for anaog and digital control.
	        IF #Ib_LvlOn_ThirdEqp THEN
	            #b_ThirdEqpReq := TRUE;
	        END_IF;
	        IF #Ib_LvlOff_ThirdEqp THEN
	            #b_ThirdEqpReq := FALSE;
	        END_IF;
	    ELSE
	        #b_ThirdEqpReq := false;
	    END_IF;
	    
	END_IF;
	
	// Set Output For Motor 1
	#Ob_ReqFirstEqp := #Ib_RequestEqp AND #b_FirstEqpReq;
	
	//Set output for Motor 2
	#Ob_ReqSecondEqp := #Ib_RequestEqp AND #b_SecondEqpReq;
	
	//Set output for Motor 3
	#Ob_ReqThirdEqp := #Ib_RequestEqp AND #b_ThirdEqpReq;
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_CM_Machine_Status"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
   VAR_INPUT 
      Ib_RunReq : Bool;   // Request to Start Disk Filter
      Ib_Sta_Run : Bool;   // Feedback from DiskFilter of Running Mode
      Ib_Sta_Fail : Bool;   // Feedback from DiskFilter of Failure Mode
      Iby_IlFwd { ExternalVisible := 'False'} : Byte;   //  8 interlock bits : 1 prevents run forward
      Ib_Ext_Signal : Bool;   // External signal dedicated for general purpouse action
      Ib_DisAlmWrn : Bool;   // Command to Disable Alarm
      Ib_ErrorEqp1 : Bool;   // Eqp 1 error or fault
      Ib_ErrorEqp2 : Bool;   // Eqp 2 error or fault
      Ib_StaEqp1 : Bool;   // Eqp 1 feedback stand alone
      Ib_StaEqp2 : Bool;   // Eqp 2 feedback stand alone
   END_VAR

   VAR_OUTPUT 
      Ob_StartReq : Bool;   // Request to Disk Filter go to Running mode
      Ob_StaAlm : Bool;   // Feedback Alarm
      Odi_HmiSta : DInt;   //  State bits for HMI
      Oi_HmiAlm : Int;   //  Alarm bit for HMI
      Odi_ActCouRst : DInt := 0;   //  Actuation counter from last reset
      Odi_ActCouTot : DInt := 0;   //  Total actuation counter
      Odi_RunTimRst : DInt;   //  Operating hours from last reset
      Odi_RunTimTot : DInt;   //  Total operating hours
      Ob_StaRunning : Bool;   // Inform that the equipment is ready to operate
   END_VAR

   VAR_IN_OUT 
      IO_AreaCmd : "UDT_AreaCmd";   //  Command bits from area
      IOdi_HmiCmd : DInt;   //  Command bits from HMI
      IO_AreaFb : "UDT_AreaFb";   //  Feedback bits to area
      Ii_ParTFb : Int := 5;   //  time out value for feedback monitoring
   END_VAR

   VAR 
      b_RunReq : Bool;
      b_Running : Bool;
      b_Failure : Bool;
      b_General_Purpouse : Bool;
      b_NoAlm : Bool;
      b_RstAlm : Bool;
      b_dummy : Bool;
      i_dummy : Int;
      i_AlmAck : Int;
      b_StaAlmNew : Bool;
      b_CmdAutoStart : Bool;
      b_CmdReqStart : Bool;   // Commando to Request to Start System
      b_CmdStart : Bool;   // Commando to Start System
      b_ReqAut { ExternalVisible := 'False'} : Bool;   //  automatic mode requested
      b_ReqMan { ExternalVisible := 'False'} : Bool;   //  manual mode requested
      b_ReqDis { ExternalVisible := 'False'} : Bool;   //  disabled mode requested
      b_DisAlmWrn : Bool;
      b_StatusReady : Bool;
      FB_UTIL_Work_H_Rst : "FB_UTIL_Work_H";
      FB_UTIL_Work_H_Tot : "FB_UTIL_Work_H";
      FB_UTIL_TON_Del_1 { ExternalVisible := 'False'} : "FB_UTIL_TON_Sec";
      b_FbErrRun { S7_SetPoint := 'True'} : Bool;   // Error to go to Run Mode Feedback
      b_StaSim { ExternalVisible := 'False'} : Bool;   //  state simulation ON
      b_HmiCmdModAut { ExternalVisible := 'False'} : Bool;   //  command change mode to AUTO
      b_HmiCmdModMan { ExternalVisible := 'False'} : Bool;   //  command change mode to MANUAL
      b_HmiCmdModDis { ExternalVisible := 'False'} : Bool;   //  command change mode to DISABLED
      b_HmiCmdSim { ExternalVisible := 'False'} : Bool;   //  toggle simulation mode
      b_HmiCmdStartReq { ExternalVisible := 'False'} : Bool;   //  command Start
      b_HmiCmdStp { ExternalVisible := 'False'} : Bool;   //  command stop
      b_HmiCmdRst { ExternalVisible := 'False'} : Bool;   //  reset alarms
      b_HmiCmdRstActOpe { ExternalVisible := 'False'} : Bool;   //  reset actuation counter and operating hours
      b_StaModAut { ExternalVisible := 'False'} : Bool;   //  state AUTOMATIC
      b_StaModMan { ExternalVisible := 'False'} : Bool := TRUE;   //  state MANUAL
      b_StaModDis { ExternalVisible := 'False'} : Bool;   //  state DISABLED
      b_StaAlm { ExternalVisible := 'False'} : Bool;   //  general alarm
      b_FbSimStart { ExternalVisible := 'False'} : Bool;   //  internal feedback simulation
      b_Old_Ob_Run : Bool;
      b_StaIlOn { ExternalVisible := 'False'} : Bool;   //  state interlock ON : 1 = interlocked (prevents forward)
      b_AlmtoFb : Bool;
   END_VAR

   VAR_TEMP 
      di_AUX : Int;   //  auxiliary double word for calculation of state or alarm word to HMI
   END_VAR


BEGIN
	// =============================================================================================================================  
	// Purpose: Reditech standard typical to Communicate with any Field Machine
	// -----------------------------------------------------------------------------------------------------------------------------
	// Date (dd MMM yyyy)   Developer                   Version Comments/Reason for change
	// ..................   .........                   ....... ..........................
	// 22 May 2020          Willian Barroso               0.10    First Issue
	// 22 Jun 2020          Willian Barroso               0.20    Add Interlock Input
	// 09 Jul 2020          Ivan Galhardoni               1.00    Performed several changes in the simulation mode,HMI communication data and Auto/Man control
	// 08 Jul 2021          Ivan Galhardoni               1.01    Was changed the output command to a set command
	// =============================================================================================================================
	
	// ============================================================================================================================= 
	// Read Input Signals
	#b_RunReq := #Ib_RunReq;
	#b_Running := #Ib_Sta_Run;
	#b_General_Purpouse := #Ib_Ext_Signal;
	
	// =============================================================================================================================
	// Alarm Disable
	#b_DisAlmWrn := #Ib_DisAlmWrn OR #IO_AreaCmd.Alm.Dis OR #b_StaModDis;
	
	// =============================================================================================================================
	#b_StaIlOn := (#Iby_IlFwd <> 0);
	
	// =============================================================================================================================
	// HMI Commands
	//#b_HmiCmdModAut := #IOdi_HmiCmd.%X0;
	//#b_HmiCmdModMan := #IOdi_HmiCmd.%X1;
	//#b_HmiCmdModDis := #IOdi_HmiCmd.%X2;
	#b_HmiCmdSim := #IOdi_HmiCmd.%X3;       //Command to request simulation mode
	#b_HmiCmdStp := #IOdi_HmiCmd.%X4;       //Command to request machine to stop
	#b_HmiCmdRst := #IOdi_HmiCmd.%X5;       //Machine faceplate alarm reset command
	#b_HmiCmdStartReq := #IOdi_HmiCmd.%X6;  //Command to request machine start-up
	#b_HmiCmdRstActOpe := #IOdi_HmiCmd.%X8; //Number of starts reset button
	#IOdi_HmiCmd := 0;  //Erasing HMI commands
	// =============================================================================================================================
	// Area Mode
	IF #IO_AreaCmd.Mode.AreaMode THEN
	    #b_ReqAut := #IO_AreaCmd.Mode.Auto;
	    #b_ReqMan := #IO_AreaCmd.Mode.Man;
	    #b_ReqDis := #IO_AreaCmd.Mode.Dis;
	END_IF;
	
	IF (#b_ReqAut AND NOT #b_ReqMan AND NOT #b_ReqDis) THEN
	    #b_StaModAut := true;
	    #b_StaModMan := false;
	    #b_StaModDis := false;
	END_IF;
	IF (#b_ReqMan AND NOT #b_ReqAut AND NOT #b_ReqDis) THEN
	    #b_StaModAut := false;
	    #b_StaModMan := true;
	    #b_StaModDis := false;
	END_IF;
	IF (#b_ReqDis AND NOT #b_ReqAut AND NOT #b_ReqMan) THEN
	    #b_StaModAut := false;
	    #b_StaModMan := false;
	    #b_StaModDis := true;
	END_IF;
	
	// =============================================================================================================================
	// Simulation Mode
	IF #IO_AreaCmd.Sim.ForceOn OR (#b_HmiCmdSim AND NOT #b_StaSim AND NOT #IO_AreaCmd.Sim.ForceOn AND NOT #IO_AreaCmd.Sim.ForceOff) THEN
	    #b_StaSim := true;
	    #b_HmiCmdSim := false; // reset of command necessary, else simulation will always be reset immediately by following instructions
	END_IF;
	IF #IO_AreaCmd.Sim.ForceOff OR (#b_HmiCmdSim AND #b_StaSim AND NOT #IO_AreaCmd.Sim.ForceOn AND NOT #IO_AreaCmd.Sim.ForceOff) THEN
	    #b_StaSim := false;
	    #b_HmiCmdSim := false;
	END_IF;
	
	// =============================================================================================================================
	// Start Command Request
	IF (#b_RunReq AND NOT #b_CmdAutoStart AND NOT #b_StaModMan) OR (#b_StaModAut AND #b_RunReq AND #b_StaSim) OR #b_HmiCmdStartReq THEN //Command being requested by block input or HMI button
	    #b_CmdAutoStart := TRUE;
	END_IF;
	
	IF (#b_StaModAut AND #b_CmdAutoStart) OR (#b_StaModMan AND #b_CmdAutoStart) THEN
	    #b_CmdStart := TRUE;
	END_IF;
	 
	IF (#b_CmdStart AND NOT #b_StaAlm AND NOT #b_StaModDis AND NOT #b_StaIlOn) THEN
	    #b_CmdReqStart := TRUE; //Final logic for start command request
	END_IF;
	
	//If There is a fault, or Hmi button request to stop, set command off
	IF #b_StaAlm OR #b_StaIlOn OR #b_StaModDis
	    OR (#b_StaModMan AND  #b_HmiCmdStp)
	    OR (#b_StaModAut AND NOT #b_RunReq) THEN
	    #b_CmdReqStart := FALSE;
	    #b_CmdStart := FALSE;
	    #b_CmdAutoStart := FALSE;
	    #b_FbSimStart := FALSE;
	END_IF;
	// =============================================================================================================================
	// Simulation of Start Command Request
	IF #b_StaSim THEN //Avoiding equipment start-up in simulation mode
	    #Ob_StartReq := FALSE;
	ELSE
	    #Ob_StartReq := #b_CmdReqStart;
	END_IF;
	
	// =============================================================================================================================
	// reset simulated feedback when starting to move
	IF NOT #b_StaSim OR #b_HmiCmdStp OR #b_StaAlm THEN
	    #b_FbSimStart := false;
	END_IF;
	    
	// set simulated feedback
	IF #b_CmdReqStart AND #b_StaSim THEN
	    #b_FbSimStart := true;
	END_IF;
	
	// =============================================================================================================================
	// feedback, selection simulation or real time
	#Ob_StaRunning := (NOT #b_StaSim AND #b_Running) OR (#b_StaSim AND #b_FbSimStart);
	
	// =============================================================================================================================
	//Alarm Acknowledge
	#b_NoAlm := false;
	#b_RstAlm := #b_HmiCmdRst OR #IO_AreaCmd.Alm.Rst;
	"FC_UTIL_AlmAck"(Ib_CmdAck := #b_RstAlm,
	                 Oi_StaAlm => #i_dummy,
	                 Ob_StaAlm => #b_dummy,
	                 Ob_StaNewAlm => #b_StaAlmNew,
	                 IO_Alm0 := #b_AlmtoFb,
	                 IO_Alm1 := #b_Failure,
	                 IO_Alm2 := #b_NoAlm,
	                 IO_Alm3 := #b_NoAlm,
	                 IO_Alm4 := #b_NoAlm,
	                 IO_Alm5 := #b_NoAlm,
	                 IO_Alm6 := #b_NoAlm,
	                 IO_Alm7 := #b_NoAlm,
	                 IO_Alm8 := #b_NoAlm,
	                 IO_Alm9 := #b_NoAlm,
	                 IO_Alm10 := #b_NoAlm,
	                 IO_Alm11 := #b_NoAlm,
	                 IO_Alm12 := #b_NoAlm,
	                 IO_Alm13 := #b_NoAlm,
	                 IO_Alm14 := #b_NoAlm,
	                 IO_Alm15 := #b_NoAlm,
	                 IOi_StaAck := #i_AlmAck);
	
	// =============================================================================================================================
	//Failure Verification (Time-out feedback)
	IF (#Ii_ParTFb > 0) THEN  // only when time value > 0
	    #FB_UTIL_TON_Del_1(Ii_tValue := #Ii_ParTFb,
	                       Ib_In := (#b_CmdReqStart AND NOT #b_Running AND NOT #b_FbSimStart),
	                       Ii_Base := 1,
	                       Ib_Hold := 0,
	                       Ob_Out => #b_FbErrRun);
	END_IF;
	
	IF #Ib_Sta_Fail AND NOT #b_StaSim THEN  //Fault signal coming from machine
	    #b_Failure := TRUE;
	END_IF;
	
	IF  #b_FbErrRun AND #Ii_ParTFb > 0 AND NOT #b_DisAlmWrn AND NOT #b_StaSim THEN  //Fault feedback time out 
	    #b_AlmtoFb := TRUE;
	END_IF;
	
	#b_StaAlm := #b_Failure OR #b_AlmtoFb;
	#Ob_StaAlm := #b_StaAlm;
	
	// =============================================================================================================================
	//HMI Status bits
	#Odi_HmiSta.%X0 := #b_StaModAut;
	#Odi_HmiSta.%X1 := #b_StaModMan;
	#Odi_HmiSta.%X2 := #b_StaModDis;
	#Odi_HmiSta.%X3 := #b_StaSim;               //Eqp in Simulation mode
	#Odi_HmiSta.%X4 := #b_StaIlOn;              //Eqp interlocked
	#Odi_HmiSta.%X5 := ((#b_Running AND NOT #b_StaSim) OR #b_FbSimStart) AND NOT #b_General_Purpouse AND NOT #b_StaIlOn;  //Status feedback on
	#Odi_HmiSta.%X6 := #b_StaAlm;               //Eqp alarm activated
	#Odi_HmiSta.%X7 := (#b_Running OR #b_FbSimStart) AND #b_General_Purpouse AND NOT #b_StaAlm; //Used for a general HMI animation
	#Odi_HmiSta.%X8 := ((#b_StaSim AND #b_FbSimStart) OR (NOT #b_StaSim AND #Ib_StaEqp1)) AND NOT #b_StaIlOn; //Status feedback Eqp1
	#Odi_HmiSta.%X9 := ((#b_StaSim AND #b_FbSimStart) OR (NOT #b_StaSim AND #Ib_StaEqp2)) AND NOT #b_StaIlOn; //Status feedback Eqp1
	
	// =============================================================================================================================
	//HMI Alarms bit
	#di_AUX := 0;
	#di_AUX.%X0 := #b_AlmtoFb;  //Feedback time out error
	#di_AUX.%X1 := #b_Failure;  //Machine signal error
	#di_AUX.%X2 := #Ib_ErrorEqp1 OR #b_StaAlm; //Eqp 1 Error
	#di_AUX.%X3 := #Ib_ErrorEqp2 OR #b_StaAlm; //Eqp 2 Error
	
	#Oi_HmiAlm := #di_AUX;
	
	// =============================================================================================================================
	
	//IO Area Feedback
	IF #b_StaModDis THEN
	    #IO_AreaFb.Mode.Dis := TRUE;
	END_IF;
	IF #b_StaModMan THEN
	    #IO_AreaFb.Mode.Man := TRUE;
	END_IF;
	IF #b_StaModAut THEN
	    #IO_AreaFb.Mode.Auto := TRUE;
	END_IF;
	IF #b_StaAlm THEN
	    #IO_AreaFb.Alm.Alm := TRUE;
	END_IF;
	IF #b_StaAlmNew THEN
	    #IO_AreaFb.Alm.New := TRUE;
	END_IF;
	IF #b_StaSim THEN
	    #IO_AreaFb.Sim.Sim := TRUE;
	END_IF;
	
	// =============================================================================================================================
	
	//Machine start-up counter
	IF (#Ob_StartReq AND #b_Running AND NOT #b_Old_Ob_Run) THEN
	    #Odi_ActCouRst := #Odi_ActCouRst + 1;
	    #Odi_ActCouTot := #Odi_ActCouTot + 1;
	END_IF;
	IF #b_HmiCmdRstActOpe THEN
	    #Odi_ActCouRst := 0;
	END_IF;
	
	#b_Old_Ob_Run := #Ob_StartReq;
	
	//Machine Time Operation
	#FB_UTIL_Work_H_Rst(Ib_On := #Ob_StartReq,
	                    Ib_Reset := #b_HmiCmdRstActOpe,
	                    Ib_Pls1S := "Clock_1Hz",
	                    IOdi_ResultHours := #Odi_RunTimRst);
	
	#FB_UTIL_Work_H_Tot(Ib_On := #Ob_StartReq,
	                    Ib_Pls1S := "Clock_1Hz",
	                    IOdi_ResultHours := #Odi_RunTimTot);
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_Freq_Drive"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
   VAR_INPUT 
      Ir_SpOut : Real;   // Control output ACM
      Ir_ParMaxSpd : Real;   // Maximum speed
      Ir_ParMinSpd : Real;   // Minimum speed
      Ir_ParMaxRaw : Real;   // Maximum value for analog output mode
      Ir_ParMinRaw : Real;   // Minimum value for analog output mode
      Ib_Fwd : Bool;   // Control output forward ACM
      Ib_Off : Bool;   // Control output off ACM
      Ib_Reset : Bool;   // Reset alarms
      Ib_LocRem : Bool := TRUE;   // Control with PLC =1, Control local = 0
      Iw_Input : Word;   // First inputword of the drive
      Iw_Output : Word;   // First outputword of the drive
   END_VAR

   VAR_OUTPUT 
      Or_ActSpd : Real;   // Actual speed drive
      Ob_FbFwd : Bool;   // Feedback forward
      Or_MotorCurrent : Real;   // Driver Actual Current
      Ob_FbLocGenEnab : Bool;   // Local General Enable
      Ob_FbDrwTest : Bool;   // Feedback Drawer in Test Position
      Ob_FbDrwInst : Bool;   // Feedback Drawer in Insert Position
      Ob_FbEmer : Bool;   // Feedback Emergency Button
      Oi_CurrentFault : Int;   // Driver Current Fault Number
      Ob_FbRem : Bool;   // Feedback CFW11 in Remote Mode
      Ob_CommFault : Bool;   // Communication Fault signal
   END_VAR

   VAR 
      w_SpRaw : Word;
      r_SpRaw : Real;
      w_STW1 : Word;
      w_Status : Word;
      w_ActSpd : Word;
      r_ActSpd : Real;
      w_DriverCurrent : Word := 16#00;
      w_DriverFault : Word;
      I_DriveCurrent : Int := 16#0;
      R_DriveCurrent : Real;
      R_MotorActCurrent : Real;
      w_DIStatus : Word;
      b_FbLocGenEnab : Bool;   // Local General Enable
      b_FbDrwTest : Bool;   // Feedback Drawer in Test Position
      b_FbDrwInst : Bool;   // Feedback Drawer in Insert Position
      b_FbEmer : Bool;   // Feedback Emergency Button
      b_FbDI5Spare : Bool;   // Feedback DI 5 - Spare
      b_FbDI6Spare : Bool;   // Feedback DI 6 - Spare
      b_FbRem : Bool;   // Feedback CFW11 in Remote Mode
   END_VAR


BEGIN
	// =============================================================================================================================  
	// Purpose: Reditech standard typical for controlling a frequency drive with Profibus
	// -----------------------------------------------------------------------------------------------------------------------------
	// Date (dd MMM yyyy)   Developer                   Version Comments/Reason for change
	// ..................   .........                   ....... ..........................
	// 06 nov 2018          Matthias De Staelen         01      Initial frequency drive control (creation)
	// 06 Dec 2019          Ivan Galhardoni             02      Code changed to control a WEG CFW11 freq. conv. model
	//
	// --------------------------------------------------- Initial AXM Release  ----------------------------------------------------
	// =============================================================================================================================
	//
	// Read inputwords drive
	#w_Status := PEEK_WORD(area := 16#81, dbNumber := 0, byteOffset := #Iw_Input);
	#w_ActSpd := PEEK_WORD(area := 16#81, dbNumber := 0, byteOffset := #Iw_Input + 2);
	#w_DriverCurrent := PEEK_WORD(area := 16#81, dbNumber := 0, byteOffset := #Iw_Input + 4);
	#w_DriverFault := PEEK_WORD(area := 16#81, dbNumber := 0, byteOffset := #Iw_Input + 6);
	#w_DIStatus := PEEK_WORD(area := 16#81, dbNumber := 0, byteOffset := #Iw_Input + 8);
	
	//Calculating the current motor speed and linearizing
	#r_ActSpd := DINT_TO_REAL(WORD_TO_DINT(#w_ActSpd));
	#Or_ActSpd := (((#r_ActSpd - #Ir_ParMinRaw) / (#Ir_ParMaxRaw - #Ir_ParMinRaw)) * (#Ir_ParMaxSpd - #Ir_ParMinSpd)) + #Ir_ParMinSpd;
	
	// Get feedback and alarm from statusword
	#Ob_FbFwd := #w_Status.%X8; //FeedbackRUN
	#Ob_CommFault := NOT #w_Status.%X9; //Communication Fault - Driver nor ready for receive command from DCS or Master (Always 1)
	#b_FbRem := #w_Status.%X12; //Feedback Remote Mode
	#Oi_CurrentFault := WORD_TO_INT(IN := #w_DriverFault);
	
	// Get information from DI
	#b_FbLocGenEnab := #w_DIStatus.%X0;
	#b_FbDrwTest := #w_DIStatus.%X1;
	#b_FbDrwInst := #w_DIStatus.%X2;
	#b_FbEmer := #w_DIStatus.%X3;
	#b_FbDI5Spare := #w_DIStatus.%X4;
	#b_FbDI6Spare := #w_DIStatus.%X5;
	
	#Ob_FbLocGenEnab := #b_FbLocGenEnab;
	#Ob_FbDrwTest := #b_FbDrwTest;
	#Ob_FbDrwInst := #b_FbDrwInst;
	#Ob_FbEmer := #b_FbEmer;
	#Ob_FbRem := #b_FbRem;
	
	//Calculating the Motor Current (Added by Jose Maximo)
	#I_DriveCurrent := WORD_TO_INT(#w_DriverCurrent);
	#R_DriveCurrent := INT_TO_REAL(#I_DriveCurrent);
	#R_MotorActCurrent := (#R_DriveCurrent / 10);
	#Or_MotorCurrent := #R_MotorActCurrent;
	
	// Calculating output
	#r_SpRaw := ((((#Ir_SpOut - #Ir_ParMinSpd) / (#Ir_ParMaxSpd - #Ir_ParMinSpd)) * (#Ir_ParMaxRaw - #Ir_ParMinRaw)) + #Ir_ParMinRaw);
	#w_SpRaw := INT_TO_WORD(IN := (REAL_TO_INT(IN := #r_SpRaw)));
	
	// Make the controlword for the drive (Changed By Jose Maximo)
	#w_STW1.%X0 := #Ib_Fwd AND NOT #Ib_Off; // Comando Gira/Pára Motor
	#w_STW1.%X1 := TRUE; // Habilita Geral
	#w_STW1.%X2 := TRUE; // Setido do Giro do Motor (Testar)
	#w_STW1.%X3 := FALSE;
	#w_STW1.%X4 := #Ib_LocRem;
	#w_STW1.%X5 := FALSE;
	#w_STW1.%X6 := FALSE;
	#w_STW1.%X7 := #Ib_Reset;
	
	// Write the information to the outputwords
	POKE(area:=16#82,
	     dbNumber:=0,
	     byteOffset:=#Iw_Output,
	     value:=#w_STW1);
	
	POKE(area := 16#82,
	     dbNumber := 0,
	     byteOffset := #Iw_Output + 2,
	     value := #w_SpRaw);
	
END_FUNCTION_BLOCK

FUNCTION_BLOCK "PID_CM_HMI"
{ S7_Optimized_Access := 'FALSE' }
VERSION : 0.1
   VAR_INPUT 
      Ib_EnablePid : Bool;
      IO_AreaCmd : "UDT_AreaCmd";
      Ir_PvIn : Real;
      Ir_ParScMax : Real;
      Ir_ParScMin : Real;
      Ir_OutParScMax : Real;
      Ir_OutParScMin : Real;
      Iw_Cfg : Word;
      Ib_Rst : Bool;
   END_VAR

   VAR_OUTPUT 
      Oi_Op_Mode : Int;
      Or_PvInMax : Real;
      Or_PvInMin : Real;
      Or_OutScMax : Real;
      Or_OutScMin : Real;
      Ob_ChangePID_Mode : Bool;
   END_VAR

   VAR_IN_OUT 
      Ir_ManualValue : Real;   // Manual value for PID output
      IOdi_HmiCmd : DInt;   // Hmi received command bits
      Ir_ProportionalGain : Real;   // Kp
      Ir_IntregativeTime : Real;   // Ti
      Ir_DerivativeTime : Real;   // Td
      Ir_AutSp : Real;   // Automatic set point
      IOr_PropotionalGain : Real;
      IOr_IntegrativeTime : Real;
      IOr_DerivativeTime : Real;
      Ob_InvertControl : Bool;
   END_VAR

   VAR 
      Auto_Mode : Bool;
      Manual_Mode : Bool;
      Disabled_Mode : Bool;
      Or_PidValue : Real;
      Odi_HmiSta : DInt;
      Ob_Alm : Bool;
      Odi_HmiAlm : DInt;
      Ob_Rst : Bool;
      b_Engineering_Control : Bool;
   END_VAR


BEGIN
	//Author: Ivan Galhardoni
	//Date: 19/May/2020
	//Usage: Block used for HMI communicatoion and PID control interface
	
	#Auto_Mode := #IO_AreaCmd.Mode.Auto;
	#Manual_Mode := #IO_AreaCmd.Mode.Man;
	#Disabled_Mode := #IO_AreaCmd.Mode.Dis;
	
	IF NOT #b_Engineering_Control THEN
	    #Ob_ChangePID_Mode := FALSE; //Erasing the rising edge signal to change the PID mode 
	    
	    //Writing the Operation mode to the PID controller
	    IF #Auto_Mode THEN
	        #Oi_Op_Mode := 3;
	        #Ir_ManualValue := 0.0;
	    END_IF;
	    
	    IF #Manual_Mode THEN
	        #Oi_Op_Mode := 4;
	    END_IF;
	    
	    IF #Disabled_Mode THEN
	        #Oi_Op_Mode := 0;
	        #Ir_ManualValue := 0.0;
	    END_IF;
	    
	    //Scaling the PID controller input and output according to the controlled variable
	    #Or_PvInMax := #Ir_ParScMax;
	    #Or_PvInMin := #Ir_ParScMin;
	    #Or_OutScMax := #Ir_OutParScMax;
	    #Or_OutScMin := #Ir_OutParScMin;
	    
	    //Selecting the controller direction type (Inverted or Direct)
	    #Ob_InvertControl := #Iw_Cfg.%X0;
	    
	    //Preparing the PID controller constants 
	    IF #IOdi_HmiCmd.%X2 THEN
	        #IOr_PropotionalGain := #Ir_ProportionalGain;
	        #IOr_IntegrativeTime := #Ir_IntregativeTime;
	        #IOr_DerivativeTime := #Ir_DerivativeTime;
	    END_IF;
	    
	    
	    
	    IF #Oi_Op_Mode <> #Odi_HmiSta THEN
	        
	        IF #Oi_Op_Mode = 0 AND #Odi_HmiSta <> 0 THEN
	            #Ob_ChangePID_Mode := TRUE;
	        END_IF;
	        
	        IF #Oi_Op_Mode = 4 AND #Odi_HmiSta <> 4 THEN
	            #Ob_ChangePID_Mode := TRUE;
	        END_IF;
	        
	    END_IF;
	    
	    IF #Oi_Op_Mode = 3 AND #Ib_EnablePid AND #Odi_HmiSta <> 3 THEN
	        #Ob_ChangePID_Mode := TRUE;
	    ELSIF #Oi_Op_Mode = 3 AND NOT #Ib_EnablePid AND #Odi_HmiSta = 3 THEN
	        #Ob_ChangePID_Mode := TRUE;
	        #Oi_Op_Mode := 0;
	    END_IF;
	    
	    
	    
	    
	    
	    //If there is an alarm, set up output alarm boolean
	    IF #Odi_HmiAlm > 0 THEN
	        #Ob_Alm := TRUE;
	    ELSE
	        #Ob_Alm := FALSE;
	    END_IF;
	    
	    #Ob_Rst := #Ib_Rst OR #IOdi_HmiCmd.%X1; //Reset the PID controller block
	    
	(* Hmi command bits must be reset at the end of the routine *)
	END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_DiagModule"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      I_Panel : "UDT_HWID_RR";   // Panel Tag
      Ii_RackNb : Int;   // Rack number of the Panel
   END_VAR

   VAR_OUTPUT 
      IO_DiaMod_Panel_Fb : "UDT_HWDS_IO";   // Channels alarm feedback
   END_VAR

   VAR 
      Hw_Identifier : HW_DEVICE;
      i_RackNb : Int;
      b_State : Array[0..1024] of Bool;
      i_Counter_01 : Int;
   END_VAR

   VAR_TEMP 
      i_temp1 : Int;
      i_temp2 : Int;
      b_temp1 : Bool;
      b_temp2 : Bool;
   END_VAR


BEGIN
	// =============================================================================================================================  
	// Purpose: Reditech standard typical to Diagnostic an IO Module 
	// -----------------------------------------------------------------------------------------------------------------------------
	// Date (dd MMM yyyy)   Developer                   Version Comments/Reason for change
	// ..................   .........                   ....... ..........................
	// 08 May 2020          Willian Barroso               0.10    First Issue
	// 01 Jun 2020          Willian Barroso               0.20    Second Issue
	// =============================================================================================================================
	
	//============================================================================================ 
	    #i_RackNb := #Ii_RackNb;
	    #Hw_Identifier := #I_Panel.RACK[#i_RackNb];
	    
	    // Read current state of module
	    #i_temp1 := ModuleStates(LADDR := #Hw_Identifier, MODE := 5, STATE := #b_State);
	    
	    REGION Alarm Acknowledge
	        "FC_UTIL_AlmAck"(Ib_CmdAck := "b_GenRst",
	                         Oi_StaAlm => #i_temp1,
	                         Ob_StaAlm => #b_temp1,
	                         Ob_StaNewAlm => #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].StaNewAlarm1,
	                         IO_Alm0 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[0],
	                         IO_Alm1 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[1],
	                         IO_Alm2 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[2],
	                         IO_Alm3 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[3],
	                         IO_Alm4 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[4],
	                         IO_Alm5 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[5],
	                         IO_Alm6 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[6],
	                         IO_Alm7 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[7],
	                         IO_Alm8 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[8],
	                         IO_Alm9 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[9],
	                         IO_Alm10 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[10],
	                         IO_Alm11 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[11],
	                         IO_Alm12 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[12],
	                         IO_Alm13 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[13],
	                         IO_Alm14 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[14],
	                         IO_Alm15 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[15],
	                         IOi_StaAck := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].StaAck1);
	        
	        "FC_UTIL_AlmAck"(Ib_CmdAck := "b_GenRst",
	                         Oi_StaAlm => #i_temp2,
	                         Ob_StaAlm => #b_temp2,
	                         Ob_StaNewAlm => #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].StaNewAlarm2,
	                         IO_Alm0 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[16],
	                         IO_Alm1 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[17],
	                         IO_Alm2 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[18],
	                         IO_Alm3 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[19],
	                         IO_Alm4 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[20],
	                         IO_Alm5 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[21],
	                         IO_Alm6 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[22],
	                         IO_Alm7 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[23],
	                         IO_Alm8 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[24],
	                         IO_Alm9 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[25],
	                         IO_Alm10 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[26],
	                         IO_Alm11 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[27],
	                         IO_Alm12 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[28],
	                         IO_Alm13 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[29],
	                         IO_Alm14 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[30],
	                         IO_Alm15 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[31],
	                         IOi_StaAck := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].StaAck2);
	    END_REGION
	    
	    REGION Conditions for Alarms
	        FOR #i_Counter_01 := 0 TO 31 DO
	            
	            IF #b_State[#i_Counter_01] THEN
	                #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[#i_Counter_01] := 1;
	            END_IF;
	            
	        END_FOR;
	    END_REGION
	    
	    REGION Copy Alarms TO HMI
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X0 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[0];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X1 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[1];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X2 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[2];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X3 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[3];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X4 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[4];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X5 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[5];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X6 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[6];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X7 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[7];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X8 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[8];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X9 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[9];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X10 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[10];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X11 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[11];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X12 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[12];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X13 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[13];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X14 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[14];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X15 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[15];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X16 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[16];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X17 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[17];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X18 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[18];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X19 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[19];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X20 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[20];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X21 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[21];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X22 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[22];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X23 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[23];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X24 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[24];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X25 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[25];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X26 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[26];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X27 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[27];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X28 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[28];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X29 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[29];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X30 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[30];
	        #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].di_HMI.%X31 := #IO_DiaMod_Panel_Fb.RACK[#i_RackNb].SLOT[31];
	    END_REGION
	    
END_FUNCTION_BLOCK

FUNCTION_BLOCK "FB_CM_ACM"
TITLE = FB_AXV
{ S7_Optimized_Access := 'FALSE' }
AUTHOR : Reditech
FAMILY : Typicals
NAME : FB_AXV
VERSION : 0.1
//analog valve control
   VAR_INPUT 
      Ib_AutFwd { ExternalVisible := 'False'} : Bool;   //  automatic command forward
      Ib_AutRev { ExternalVisible := 'False'} : Bool;   //  automatic command reversed
      Ib_FbFwd { ExternalVisible := 'False'} : Bool;   //  feedback forward
      Ib_FbRev { ExternalVisible := 'False'} : Bool;   //  feedback reversed
      ib_Is { ExternalVisible := 'False'} : Bool;   //  Status Isolation switch (0=ok, 1=error)
      Ib_Mps { ExternalVisible := 'False'} : Bool;   //  Status motor protection switch (0=ok, 1 = error)
      Ib_DevFlt : Bool;
      Iby_Saf { ExternalVisible := 'False'} : Byte;   //  8 safety bits : 1=error
      Iby_IlFwd { ExternalVisible := 'False'} : Byte;   //  8 interlock bits : 1 prevents run forward
      Iby_IlRev { ExternalVisible := 'False'} : Byte;   //  8 interlock bits : 1 prevents run reverse
      Ib_Pls1S : Bool;
      Ir_ActSpd : Real;   //  Actual speed (measurement)
      Ir_ParMaxSpd : Real;   //  Maximum speed
      Ir_ParMinSpd : Real;   //  Minimum speed
      Ir_ParCtlDev : Real;   //  Control deviation (for digital output and feedback OK)
      Ir_ParSafSpd : Real;   //  Safety speed
      Ii_ParTO : Int;   //  time out value for speed feedback monitoring
      Ii_ParTFb : Int;   //  time out value for fwd or rev feedback monitoring
      Ii_ParTToRun : Int;   //  time out value for time out run
      Ib_DisAlmWrn : Bool;
      Iw_Cfg { ExternalVisible := 'False'} : Word := 1;   //  .0=analog pos present / .1=digital pos present
      Ir_MotorCurrent { ExternalVisible := 'False'} : Real;   // Feedback of the Motor current from Freq_Driver Block
      Ib_LocGenEnab : Bool;   // Local General Enable Feedback from CFW11
      Ib_DrwTest : Bool;   // Feedback for Drawer in Test Position
      Ib_DrwInst : Bool;   // Feedback for Drawer in Insert Position
      Ii_CurFault : Int;   // Number of Current Fault from CFW11
      Ib_FbRem : Bool;   // Feedback CFW11 in Remote Mode
   END_VAR

   VAR_OUTPUT 
      Or_SpOut : Real;   //  Control output
      Ob_Fwd { ExternalVisible := 'False'} : Bool;   //  control output forward
      Ob_Rev { ExternalVisible := 'False'} : Bool;   //  control output reverse
      Ob_Off { ExternalVisible := 'False'} : Bool := TRUE;   //  control output off
      Ob_StaFwd : Bool;   //  Status forward running
      Ob_StaRev : Bool;   //  Status reverse running
      Ob_StaOff : Bool := TRUE;   //  Status Off (not running)
      Ob_SpdOk { ExternalVisible := 'False'} : Bool;   //  speed reached
      Or_StaSpd : Real;
      Ob_Alm { ExternalVisible := 'False'} : Bool;   //  general alarm
      Ob_Wrn : Bool;   //  general warning
      Odi_HmiSta : DInt;   //  State bits for HMI
      Odi_HmiAlm : DInt;   //  Alarm bit for HMI
      Odi_ActCouRst : DInt := 0;   //  Actuation counter from last reset
      Odi_ActCouTot : DInt := 0;   //  Total actuation counter
      Odi_RunTimRst : DInt;   //  Operating hours from last reset
      Odi_RunTimTot : DInt;   //  Total operating hours
      Oi_HmiAlm : Int;   //  Pure alarm bits for HMI
      Ob_LocRem : Bool := 0;   // Remote Operation: 0= Local Op; 1= Remote Op
   END_VAR

   VAR_IN_OUT 
      IOdi_HmiCmd : DInt;   //  Command bits from HMI
      IOr_ManSP : Real;   //  manual setpoint
      IOr_AutSp : Real;   //  automatic setpoint
      IOr_SimSpd : Real;   //  Simulated speed
      IO_AreaCmd : "UDT_AreaCmd";   //  Command bits from area
      IO_AreaFb : "UDT_AreaFb";   //  Feedback bits to area
   END_VAR

   VAR 
      b_HmiCmdModAut { ExternalVisible := 'False'} : Bool;   //  command change mode to AUTO
      b_HmiCmdModMan { ExternalVisible := 'False'} : Bool;   //  command change mode to MANUAL
      b_HmiCmdModDis { ExternalVisible := 'False'} : Bool;   //  command change mode to DISABLED
      b_HmiCmdSim { ExternalVisible := 'False'} : Bool;   //  toggle simulation mode
      b_HmiCmdRst { ExternalVisible := 'False'} : Bool;   //  reset alarms
      b_HmiCmdAutoSim { ExternalVisible := 'False'} : Bool;   //  toggle automatic simulation value
      b_HmiCmdFwd { ExternalVisible := 'False'} : Bool;   //  command start forward
      b_HmiCmdRev { ExternalVisible := 'False'} : Bool;   //  command start reversed
      b_HmiCmdStp { ExternalVisible := 'False'} : Bool;   //  command stop
      b_HmiCmdRstActOpe { ExternalVisible := 'False'} : Bool;   //  reset actuation counter and operating hours
      b_StaModAut { ExternalVisible := 'False'} : Bool;   //  state AUTOMATIC
      b_StaModMan { ExternalVisible := 'False'} : Bool := TRUE;   //  state MANUAL
      b_StaModDis { ExternalVisible := 'False'} : Bool;   //  state DISABLED
      b_StaSim { ExternalVisible := 'False'} : Bool;   //  state simulation ON
      b_StaIlOn { ExternalVisible := 'False'} : Bool;   //  state interlock ON : 1 = interlocked (prevents forward)
      b_StaIlRev : Bool;   //  state interlock ON : 1 = interlocked (prevents reverse)
      b_StaSaf { ExternalVisible := 'False'} : Bool;   //  state safety : 1 = error (valve to safety position)
      b_StaAutoSim { ExternalVisible := 'False'} : Bool;   //  Auto sim (Ir_ActSpd simulated)
      b_ReqFwd { ExternalVisible := 'False'} : Bool;   //  output forward
      b_ReqRev { ExternalVisible := 'False'} : Bool;   //  output reversed
      b_StaSpdOk { ExternalVisible := 'False'} : Bool;   //  speed (setpoint) reached
      b_StaAlm { ExternalVisible := 'False'} : Bool;   //  general alarm
      b_StaWrn { ExternalVisible := 'False'} : Bool;   //  general warning
      b_CfgAnaSpdPres { ExternalVisible := 'False'} : Bool;   //  configuration : analog speed feedback present
      b_CfgEnRev { ExternalVisible := 'False'} : Bool;   //  configuration : reversed direction enabled
      b_CfgHldMod { ExternalVisible := 'False'} : Bool;   //  Configuration : status bit mode after reset (1 = auto, 0 = manual)
      b_CfgPushToRun { ExternalVisible := 'False'} : Bool;
      b_CfgDisableSim { ExternalVisible := 'False'} : Bool;
      b_CfgStopArea { ExternalVisible := 'False'} : Bool;
      b_AlmToFb { ExternalVisible := 'False'} : Bool;   //  alarm time out feedback
      b_AlmToRun { ExternalVisible := 'False'} : Bool;   //  alarm run time too long
      b_AlmIs { ExternalVisible := 'False'} : Bool;   //  alarm isolation switch
      b_AlmMps { ExternalVisible := 'False'} : Bool;   //  alarm motor protection switch
      b_AlmDevFlt { ExternalVisible := 'False'} : Bool;   //  alarm device fault
      b_ReqAut { ExternalVisible := 'False'} : Bool;   //  automatic mode requested
      b_ReqMan { ExternalVisible := 'False'} : Bool;   //  manual mode requested
      b_ReqDis { ExternalVisible := 'False'} : Bool;   //  disabled mode requested
      b_TFbSpd { ExternalVisible := 'False'} : Bool;   //  timer finished, feedback monitoring Pos1
      b_SpChange : Bool;
      r_SpSel { ExternalVisible := 'False'} : Real;   //  selected setpoint
      r_SpPrev : Real;
      r_DevMax { ExternalVisible := 'False'} : Real;
      r_DevMin { ExternalVisible := 'False'} : Real;
      b_CmdManFwd { ExternalVisible := 'False'} : Bool;   //  internal memo : manual command forward
      b_CmdManRev { ExternalVisible := 'False'} : Bool;   //  internal memo : manual command reversed
      b_CmdAutFwd { ExternalVisible := 'False'} : Bool;   //  internal memo : automatic command forward
      b_CmdAutRev { ExternalVisible := 'False'} : Bool;   //  internal memo : automatic command reversed
      b_CmdFwd { ExternalVisible := 'False'} : Bool;   //  internal memo : command forward (combined manual and auto)
      b_CmdRev { ExternalVisible := 'False'} : Bool;   //  internal memo : command reversed(combined manual and auto)
      b_FbErrSpd { ExternalVisible := 'False'} : Bool;   //  internal memo : error detection feedback analogue value
      b_TFbOnOut { ExternalVisible := 'False'} : Bool;   //  timer finished for feedback monitoring run (Fwd OR Rev)
      b_TFbOffOut { ExternalVisible := 'False'} : Bool;   //  timer finished for feedback monitoring stop
      b_TToRunOut { ExternalVisible := 'False'} : Bool;   //  timer finished for time out run
      i_TmrToRun : Int;   //  timer time out  run control
      i_TmrFbFwd { ExternalVisible := 'False'} : Int;   //  timer for feedback simulation (set) after start
      i_TmrFbRev { ExternalVisible := 'False'} : Int;   //  timer for feedback simulation (reset) after stop
      b_TFbFwdOut { ExternalVisible := 'False'} : Bool;   //  timer finished for simulation run (Fwd OR Rev)
      b_TFbRevOut { ExternalVisible := 'False'} : Bool;   //  timer finished for simulation stopped
      FB_UTIL_TON_Del_1 : "FB_UTIL_TON_Sec";
      FB_UTIL_TON_Del_2 : "FB_UTIL_TON_Sec";
      FB_UTIL_TON_Del_3 : "FB_UTIL_TON_Sec";
      FB_UTIL_TON_Del_4 : "FB_UTIL_TON_Sec";
      b_Old_ob_Fwd : Bool;
      b_Old_ob_Rev : Bool;
      FB_UTIL_Work_H_Rst { ExternalVisible := 'False'} : "FB_UTIL_Work_H";
      FB_UTIL_Work_H_Tot { ExternalVisible := 'False'} : "FB_UTIL_Work_H";
      b_FbSimFwd : Bool;
      b_FbSimRev : Bool;
      b_FbErrFwd : Bool;
      b_FbErrRev : Bool;
      i_TmrFbSpd : Int;
      b_DisAlmWrn : Bool;
      b_dummy : Bool;
      i_dummy : Int;
      b_StaAlmNew : Bool;
      b_NoAlm : Bool;
      i_AlmAck : Int;
      b_DisAlmWrn_1 : Bool;
      b_RstAlm : Bool;
      b_HmiCmdLoc : Bool;
      b_HmiCmdRem : Bool;
      i_ErrCod : Int;
      b_LocGenEnab : Bool;
      b_DrwTest : Bool;
      b_DrwInst : Bool;
      b_DrwNotIns : Bool;
      b_ErrorCFW : Bool;
      b_RemoteM : Bool;
      b_ManutLocal { ExternalVisible := 'False'} : Bool;   // command change mode to "Manut.Local"
      b_FbRem : Bool;
      b_PerRemMod : Bool;
      I_HmiSta : Word;
      i_Category : Int := 1;   // Device alarm category setting
      b_NoFeedback : Bool;
      b_EnDisPump : Bool;   // Enable/Disable HMI option
   END_VAR

   VAR_TEMP 
      di_AUX : DInt;   //  auxiliary double word for calculation of state or alarm word to HMI
   END_VAR


BEGIN
	// =============================================================================================================================  
	// Purpose: Reditech standard typical for controlling a frequency driven motor
	// -----------------------------------------------------------------------------------------------------------------------------
	// Date (dd MMM yyyy)   Developer                   Version Comments/Reason for change
	// ..................   .........                   ....... ..........................
	// 13 Dec 2018          Bram Verheyen               08.0    Full review
	// 30 Jan 2019          Matthias De Staelen         08.1    Outputs can be high in simulation mode
	// 13 Mar 2020          Willian Barroso             08.2    Full review
	// 01 Jul 2021          Ivan Galhardoni             08.3    Added NoFeedback function
	// 03 Jul 2021          Ivan Galhardoni             08.4    Added No communication fault alarm and erase manual setpoint when interlock is incoming
	// =============================================================================================================================
	
	//============================================================================================
	#b_CfgAnaSpdPres := #Iw_Cfg.%X0;      // Analog speed feedback present
	#b_CfgEnRev := #Iw_Cfg.%X1;           // Reverse direction enable
	#b_CfgHldMod := #Iw_Cfg.%X2;          // Mode after reset (1 => auto, 0 => manual)
	#b_NoFeedback := #Iw_Cfg.%X3;         // No feedback configured
	#b_CfgPushToRun := #Iw_Cfg.%X8;
	#b_CfgDisableSim := #Iw_Cfg.%X10;
	#b_CfgStopArea := #Iw_Cfg.%X11;
	
	//============================================================================================
	#b_DisAlmWrn := #Ib_DisAlmWrn OR #IO_AreaCmd.Alm.Dis OR #b_StaModDis OR #b_StaSim;
	
	//============================================================================================
	#b_StaSaf := (#Iby_Saf <> 0) AND NOT #b_DisAlmWrn;
	#b_StaIlOn := (#Iby_IlFwd <> 0);
	//#b_StaIlRev := (#Iby_IlRev <> 0);
	
	//============================================================================================
	IF #b_StaSim THEN
	    #i_ErrCod := 15;
	    #b_LocGenEnab := TRUE;
	    #b_FbRem := TRUE;
	ELSE
	    #i_ErrCod := #Ii_CurFault;
	    #b_LocGenEnab := #Ib_LocGenEnab;
	    #b_FbRem := #Ib_FbRem;
	END_IF;
	
	#b_DrwTest := #Ib_DrwTest;
	#b_DrwInst := #Ib_DrwInst;
	
	//============================================================================================
	#b_HmiCmdModAut := #IOdi_HmiCmd.%X0;
	#b_HmiCmdModMan := #IOdi_HmiCmd.%X1;
	#b_HmiCmdModDis := #IOdi_HmiCmd.%X2;
	#b_HmiCmdSim := #IOdi_HmiCmd.%X3;
	#b_HmiCmdFwd := #IOdi_HmiCmd.%X4;
	#b_HmiCmdRev := #IOdi_HmiCmd.%X5;
	#b_HmiCmdStp := #IOdi_HmiCmd.%X6;
	#b_HmiCmdAutoSim := #IOdi_HmiCmd.%X8;
	#b_HmiCmdRstActOpe := #IOdi_HmiCmd.%X9;
	#b_ManutLocal := #IOdi_HmiCmd.%X10;
	
	//============================================================================================
	  
	IF #b_CfgPushToRun THEN
	    #IOdi_HmiCmd := DWORD_TO_DINT(DINT_TO_DWORD(#IOdi_HmiCmd) AND 48);
	ELSE
	    #IOdi_HmiCmd := 0;
	END_IF; 
	
	
	//============================================================================================
	IF  #IO_AreaCmd.Mode.AreaMode THEN
	    #b_ReqAut := #IO_AreaCmd.Mode.Auto;
	    #b_ReqMan := #IO_AreaCmd.Mode.Man;
	    #b_ReqDis := #IO_AreaCmd.Mode.Dis;
	 
	ELSE 
	    IF #b_CfgHldMod THEN
	        #b_ReqAut := #b_HmiCmdModAut;
	        #b_ReqMan := #b_HmiCmdModMan;
	        #b_ReqDis := #b_HmiCmdModDis;
	   
	    ELSE
	        #b_ReqAut := #b_HmiCmdModAut AND NOT #b_StaAlm AND NOT #b_StaSaf;
	        #b_ReqMan := #b_HmiCmdModMan OR ((#b_StaAlm OR #b_StaSaf) AND NOT #b_StaModDis);
	        #b_ReqDis := #b_HmiCmdModDis;
	    END_IF;
	END_IF;
	IF (#b_ReqAut AND NOT #b_ReqMan AND NOT #b_ReqDis) THEN
	    #b_StaModAut := true;
	    #b_StaModMan := false;
	    #b_StaModDis := false;
	END_IF;
	IF (#b_ReqMan AND NOT #b_ReqAut AND NOT #b_ReqDis) THEN
	    #b_StaModAut := false;
	    #b_StaModMan := true;
	    #b_StaModDis := false;
	END_IF;
	IF (#b_ReqDis AND NOT #b_ReqMan AND NOT #b_ReqAut) THEN
	    #b_StaModAut := false;
	    #b_StaModMan := false;
	    #b_StaModDis := true;
	END_IF;
	
	//============================================================================================
	IF #IO_AreaCmd.Sim.ForceOn OR (#b_HmiCmdSim AND NOT #b_StaSim AND NOT #IO_AreaCmd.Sim.ForceOn AND NOT #IO_AreaCmd.Sim.ForceOff) THEN
	    #b_StaSim := true;
	    #b_HmiCmdSim := false; // reset of command necessary, else simulation will always be reset immediately by following instructions
	END_IF;
	IF #IO_AreaCmd.Sim.ForceOff OR (#b_HmiCmdSim AND #b_StaSim AND NOT #IO_AreaCmd.Sim.ForceOn AND NOT #IO_AreaCmd.Sim.ForceOff) THEN
	    #b_StaSim := false;
	    #b_HmiCmdSim := false;
	END_IF;
	
	//============================================================================================
	IF (#b_ReqFwd AND NOT #b_FbSimFwd)
	    OR (#b_ReqRev AND NOT #b_FbSimRev)
	    OR #b_HmiCmdStp
	    OR (NOT #b_ReqFwd AND NOT #b_ReqRev)
	    OR #b_StaIlOn
	    OR #b_StaAlm THEN
	    #b_FbSimFwd := false;
	    #b_FbSimRev := false;
	END_IF;
	
	IF ((#i_TmrFbFwd <= 1) OR #Ii_ParTFb = 0) AND #b_ReqFwd THEN
	    #b_FbSimFwd := true;
	    #b_FbSimRev := false;
	END_IF;
	
	IF ((#i_TmrFbRev <= 1) OR #Ii_ParTFb = 0) AND #b_ReqRev THEN
	    #b_FbSimFwd := false;
	    #b_FbSimRev := true;
	END_IF;
	
	//============================================================================================
	#r_DevMax := #r_SpSel + #Ir_ParCtlDev;
	#r_DevMin := #r_SpSel - #Ir_ParCtlDev;
	IF #b_StaSim AND #Ib_Pls1S THEN
	    IF (#IOr_SimSpd <= #r_DevMin) THEN
	        #IOr_SimSpd := #IOr_SimSpd + #Ir_ParCtlDev;
	    END_IF;
	    IF (#IOr_SimSpd >= #r_DevMax) THEN
	        #IOr_SimSpd := #IOr_SimSpd - #Ir_ParCtlDev;
	    END_IF;
	END_IF;
	
	// ACM: select speed
	IF #b_StaSim THEN
	    #Or_StaSpd := #IOr_SimSpd;
	ELSE
	    #Or_StaSpd := #Ir_ActSpd;
	END_IF;
	
	//============================================================================================
	#Ob_StaFwd := (NOT #b_StaSim AND #Ib_FbFwd)
	OR (#b_StaSim AND #b_FbSimFwd)
	OR (#b_NoFeedback AND #r_SpSel > 0.00);
	
	#Ob_StaRev := (NOT #b_StaSim AND #Ib_FbRev)
	OR (#b_StaSim AND #b_FbSimRev);
	
	#Ob_StaOff := NOT #Ob_StaFwd AND NOT #Ob_StaRev;
	
	#b_StaSpdOk := (NOT #b_CfgAnaSpdPres)
	OR (#b_CfgAnaSpdPres AND (#Or_StaSpd > #r_DevMin) AND (#Or_StaSpd < #r_DevMax));
	#Ob_SpdOk := #b_StaSpdOk AND NOT #b_StaAlm;
	
	//============================================================================================
	#b_SpChange := (#r_SpSel <> #r_SpPrev);
	#r_SpPrev := #r_SpSel;
	
	//============================================================================================
	#b_NoAlm := false;
	#b_RstAlm := #b_HmiCmdRst OR #IO_AreaCmd.Alm.Rst;
	"FC_UTIL_AlmAck"(Ib_CmdAck := #b_RstAlm,
	                 Oi_StaAlm => #i_dummy,
	                 Ob_StaAlm => #b_dummy,
	                 Ob_StaNewAlm => #b_StaAlmNew,
	                 IO_Alm0 := #b_AlmToFb,
	                 IO_Alm1 := #b_AlmToRun,
	                 IO_Alm2 := #b_AlmIs,
	                 IO_Alm3 := #b_AlmMps,
	                 IO_Alm4 := #b_StaWrn,
	                 IO_Alm5 := #b_AlmDevFlt,
	                 IO_Alm6 := #b_ErrorCFW,
	                 IO_Alm7 := #b_DrwNotIns,
	                 IO_Alm8 := #b_NoAlm,
	                 IO_Alm9 := #b_NoAlm,
	                 IO_Alm10 := #b_NoAlm,
	                 IO_Alm11 := #b_NoAlm,
	                 IO_Alm12 := #b_NoAlm,
	                 IO_Alm13 := #b_NoAlm,
	                 IO_Alm14 := #b_NoAlm,
	                 IO_Alm15 := #b_NoAlm,
	                 IOi_StaAck := #i_AlmAck);
	
	//============================================================================================
	IF (#Ii_ParTFb > 0) THEN  // only when time value > 0
	    #FB_UTIL_TON_Del_1(Ii_tValue := #Ii_ParTFb,
	                       Ib_In := (#b_ReqFwd AND NOT #Ob_StaFwd),
	                       Ii_Base := 1,
	                       Ib_Hold := 0,
	                       Ob_Out => #b_FbErrFwd,
	                       Oi_tmrValue => #i_TmrFbFwd);
	END_IF;
	
	IF (#Ii_ParTFb > 0) THEN  // only when time value > 0
	    #FB_UTIL_TON_Del_2(Ii_tValue := #Ii_ParTFb,
	                       Ib_In := (#b_ReqRev AND NOT #Ob_StaRev),
	                       Ii_Base := 1,
	                       Ib_Hold := 0,
	                       Ob_Out => #b_FbErrRev,
	                       Oi_tmrValue => #i_TmrFbRev);
	END_IF;
	
	IF (#Ii_ParTO > 0) THEN
	    #FB_UTIL_TON_Del_4(Ib_In := (#b_CfgAnaSpdPres AND NOT #b_StaSpdOk AND NOT #b_SpChange AND (#b_ReqFwd OR #b_ReqRev)),
	                       Ii_tValue := #Ii_ParTO,
	                       Ii_Base := 1,
	                       Ib_Hold := 0,
	                       Ob_Out => #b_FbErrSpd,
	                       Oi_tmrValue => #i_TmrFbSpd);
	END_IF;
	
	IF (((#b_FbErrFwd OR #b_FbErrRev) AND (#Ii_ParTFb > 0))
	    OR (#b_FbErrSpd AND (#Ii_ParTO > 0)))
	    AND NOT #b_DisAlmWrn THEN
	    #b_AlmToFb := true;
	END_IF;
	
	//============================================================================================
	IF (#Ii_ParTToRun > 0) THEN
	    #FB_UTIL_TON_Del_3(Ii_tValue := #Ii_ParTToRun,
	                       Ib_In := (#b_ReqFwd OR #b_ReqRev),
	                       Ii_Base := 1,
	                       Ib_Hold := 0,
	                       Ob_Out => #b_TToRunOut,
	                       Oi_tmrValue => #i_TmrToRun);
	END_IF;
	
	IF (#b_TToRunOut AND (#Ii_ParTToRun > 0))
	    AND NOT #b_DisAlmWrn THEN
	    #b_AlmToRun := true;
	END_IF;
	
	//============================================================================================
	IF #ib_Is AND NOT #b_DisAlmWrn THEN
	    #b_AlmIs := true;
	END_IF;
	
	//============================================================================================
	IF #Ib_Mps AND NOT #b_DisAlmWrn THEN
	    #b_AlmMps := true;
	END_IF;
	
	//============================================================================================
	IF #Ib_DevFlt AND NOT #b_DisAlmWrn THEN
	    #b_AlmDevFlt := true;
	END_IF;
	
	//============================================================================================
	IF NOT #b_DrwInst AND NOT #b_DrwTest AND NOT #b_DisAlmWrn THEN
	    #b_DrwNotIns := true;
	END_IF;
	
	//============================================================================================
	IF (#i_ErrCod = 10) OR (#i_ErrCod = 46) OR (#i_ErrCod = 47) OR (#i_ErrCod = 50) OR
	    (#i_ErrCod = 53) OR (#i_ErrCod = 56) OR (#i_ErrCod = 78) OR (#i_ErrCod = 80) OR (#i_ErrCod = 84) OR
	    (#i_ErrCod = 88) OR (#i_ErrCod = 99) OR (#i_ErrCod = 110) OR (#i_ErrCod = 129) OR
	    (#i_ErrCod = 130) OR (#i_ErrCod = 151) OR (#i_ErrCod = 152) OR (#i_ErrCod = 160) OR
	    (#i_ErrCod = 177) OR (#i_ErrCod = 179) OR (#i_ErrCod = 182) OR (#i_ErrCod = 700) OR
	    (#i_ErrCod = 701) AND NOT #b_DisAlmWrn
	THEN
	    #b_ErrorCFW := true;
	END_IF;
	
	//============================================================================================
	#b_StaAlm := #b_AlmToFb OR #b_AlmToRun OR #b_StaSaf OR #b_AlmIs OR #b_AlmMps OR #b_DrwNotIns
	OR #b_ErrorCFW OR #b_AlmDevFlt OR NOT #b_EnDisPump;
	#Ob_Alm := #b_StaAlm;
	
	//============================================================================================
	#b_StaWrn := (#r_SpSel < #Ir_ParMinSpd) OR (#r_SpSel > #Ir_ParMaxSpd);
	#Ob_Wrn := #b_StaWrn;
	
	//============================================================================================
	#b_CmdAutFwd := (#Ib_AutFwd AND NOT #Ib_AutRev AND NOT #Ob_Rev);
	#b_CmdAutRev := (#Ib_AutRev AND NOT #Ib_AutFwd AND NOT #Ob_Fwd) AND #b_CfgEnRev;
	
	
	IF #b_StaModAut THEN
	    #b_CmdManFwd := #b_CmdAutFwd;
	    #b_CmdManRev := #b_CmdAutRev;
	END_IF;
	
	//============================================================================================
	IF #b_StaModMan AND NOT #b_CfgPushToRun THEN
	    IF (#b_HmiCmdFwd AND NOT #Ob_Rev) THEN
	        #b_CmdManFwd := true;
	        #b_CmdManRev := false;
	    END_IF;
	    IF (#b_HmiCmdRev AND NOT #Ob_Fwd AND #b_CfgEnRev) THEN
	        #b_CmdManFwd := false;
	        #b_CmdManRev := true;
	    END_IF;
	    IF #b_HmiCmdStp OR #b_StaAlm OR #b_StaModDis OR #b_StaIlOn THEN
	        #b_CmdManFwd := false;
	        #b_CmdManRev := false;
	    END_IF;
	END_IF;
	
	IF #b_StaModMan AND #b_CfgPushToRun THEN
	    #b_CmdManFwd := #b_HmiCmdFwd AND NOT #Ob_Rev AND NOT #b_StaAlm AND NOT #b_StaModDis;
	    #b_CmdManRev := #b_HmiCmdRev AND NOT #Ob_Fwd AND NOT #b_StaAlm AND NOT #b_StaModDis AND #b_CfgEnRev;
	END_IF;
	
	IF #b_StaModDis OR NOT #b_StaModMan THEN
	    #b_CmdManFwd := false;
	    #b_CmdManRev := false;
	END_IF;
	
	//============================================================================================
	IF #b_StaModAut THEN
	    #r_SpSel := #IOr_AutSp;
	    #IOr_ManSP := #IOr_AutSp;
	END_IF;
	
	IF #b_StaModMan THEN
	    #r_SpSel := #IOr_ManSP;
	END_IF;
	
	IF #b_StaModDis OR #b_StaAlm OR #b_StaIlOn THEN
	    #r_SpSel := 0.0;
	    #IOr_ManSP := 0.0;
	END_IF;
	
	IF #b_StaSaf THEN
	    #r_SpSel := #Ir_ParSafSpd;
	END_IF;
	
	#r_SpSel := LIMIT(MN := #Ir_ParMinSpd, IN := #r_SpSel, MX := #Ir_ParMaxSpd);
	
	//============================================================================================
	#b_CmdFwd := (#b_StaModAut AND #b_CmdAutFwd) OR (#b_StaModMan AND #b_CmdManFwd) OR (#b_NoFeedback AND #r_SpSel > 0.00);
	#b_CmdRev := (#b_StaModAut AND #b_CmdAutRev) OR (#b_StaModMan AND #b_CmdManRev);
	
	//============================================================================================
	#b_ReqFwd := (#b_CmdFwd AND NOT #b_StaAlm AND NOT #b_StaIlOn AND NOT #b_StaModDis);
	#b_ReqRev := (#b_CmdRev AND NOT #b_StaAlm AND NOT #b_StaIlOn AND NOT #b_StaModDis);
	
	//============================================================================================
	IF #b_StaSim THEN
	    #Ob_Fwd := FALSE;
	    #Ob_Rev := FALSE;
	ELSE
	    #Ob_Fwd := #b_ReqFwd;
	    #Ob_Rev := #b_ReqRev;
	END_IF;
	#Ob_Off := NOT #b_ReqFwd AND NOT #b_ReqRev;
	
	IF #Ob_StaFwd THEN
	    #Or_SpOut := #r_SpSel;
	ELSE
	    #Or_SpOut := 0.0;
	END_IF;
	    
	
	//============================================================================================
	#Odi_HmiSta.%X0 := #b_StaModAut;
	#Odi_HmiSta.%X1 := #b_StaModMan;
	#Odi_HmiSta.%X2 := #b_StaModDis;
	#Odi_HmiSta.%X3 := #b_StaSim;
	#Odi_HmiSta.%X4 := #b_StaIlOn OR #b_StaSaf;
	#Odi_HmiSta.%X5 := #b_StaIlRev;
	#Odi_HmiSta.%X6 := #b_StaSaf AND NOT #b_AlmDevFlt;
	#Odi_HmiSta.%X7 := #b_StaAutoSim;
	#Odi_HmiSta.%X8 := #b_LocGenEnab;
	#Odi_HmiSta.%X9 := #b_DrwTest;
	#Odi_HmiSta.%X12 := #b_FbRem;
	#Odi_HmiSta.%X15 := #b_StaSpdOk;
	#Odi_HmiSta.%X16 := #b_ReqFwd;
	#Odi_HmiSta.%X17 := #b_ReqRev;
	#Odi_HmiSta.%X18 := #Ob_StaFwd;
	#Odi_HmiSta.%X19 := #Ob_StaRev;
	#Odi_HmiSta.%X20 := #b_StaAlm;
	#Odi_HmiSta.%X21 := #b_StaWrn;
	#Odi_HmiSta.%X28 := #IO_AreaCmd.Mode.AreaMode;
	#Odi_HmiSta.%X29 := #b_PerRemMod;
	
	#I_HmiSta.%X0 := #b_StaModAut;
	#I_HmiSta.%X1 := #b_StaModMan;
	#I_HmiSta.%X2 := #b_StaModDis;
	#I_HmiSta.%X3 := #b_StaSim;
	#I_HmiSta.%X4 := #b_StaIlOn OR #b_StaSaf;
	#I_HmiSta.%X5 := #b_StaSaf;
	#I_HmiSta.%X6 := #b_LocGenEnab;
	#I_HmiSta.%X7 := #b_FbRem;
	#I_HmiSta.%X8 := #Ob_StaFwd;
	#I_HmiSta.%X9 := #b_StaAlm;
	
	//============================================================================================
	#di_AUX := 0;
	#di_AUX.%X0 := #b_AlmToFb;
	#di_AUX.%X1 := #b_AlmToRun;
	#di_AUX.%X2 := #b_AlmIs AND NOT #b_AlmDevFlt;
	#di_AUX.%X3 := #b_AlmMps AND NOT #b_AlmDevFlt;
	#di_AUX.%X4 := #b_StaWrn;
	#di_AUX.%X5 := #b_AlmDevFlt;
	#di_AUX.%X6 := #b_DrwNotIns AND NOT #b_AlmDevFlt;
	#di_AUX.%X7 := #b_ErrorCFW AND NOT #b_AlmDevFlt;
	#di_AUX.%X16 := #Iby_IlFwd.%X0;
	#di_AUX.%X17 := #Iby_IlFwd.%X1;
	#di_AUX.%X18 := #Iby_IlFwd.%X2;
	#di_AUX.%X19 := #Iby_IlFwd.%X3;
	#di_AUX.%X20 := #Iby_IlFwd.%X4;
	#di_AUX.%X21 := #Iby_IlFwd.%X5;
	#di_AUX.%X22 := #Iby_IlFwd.%X6;
	#di_AUX.%X23 := #Iby_IlFwd.%X7;
	#di_AUX.%X24 := #Iby_Saf.%X0;
	#di_AUX.%X25 := #Iby_Saf.%X1;
	#di_AUX.%X26 := #Iby_Saf.%X2;
	#di_AUX.%X27 := #Iby_Saf.%X3;
	#di_AUX.%X28 := #Iby_Saf.%X4;
	#di_AUX.%X29 := #Iby_Saf.%X5;
	#di_AUX.%X30 := #Iby_Saf.%X6;
	#di_AUX.%X31 := #Iby_Saf.%X7;
	#Odi_HmiAlm := #di_AUX;
	
	//============================================================================================
	#di_AUX := 0;
	#di_AUX.%X0 := #b_AlmToFb;
	#di_AUX.%X1 := #b_AlmToRun AND NOT #b_AlmDevFlt;
	#di_AUX.%X2 := #b_AlmIs AND NOT #b_AlmDevFlt;
	#di_AUX.%X3 := #b_AlmMps AND NOT #b_AlmDevFlt;
	#di_AUX.%X4 := #b_StaWrn;
	#di_AUX.%X5 := #b_AlmDevFlt;
	#Oi_HmiAlm := DINT_TO_INT(#di_AUX);
	
	//============================================================================================
	IF #b_StaModDis THEN
	    #IO_AreaFb.Mode.Dis := TRUE;
	END_IF;
	IF #b_StaModMan THEN
	    #IO_AreaFb.Mode.Man := TRUE;
	END_IF;
	IF #b_StaModAut THEN
	    #IO_AreaFb.Mode.Auto := TRUE;
	END_IF;
	IF #b_StaAlm THEN
	    #IO_AreaFb.Alm.Alm := TRUE;
	END_IF;
	IF #b_StaAlmNew THEN
	    #IO_AreaFb.Alm.New := TRUE;
	END_IF;
	IF #b_StaWrn THEN
	    #IO_AreaFb.Alm.Wrn := TRUE;
	END_IF;
	IF #b_StaAlm AND #b_CfgStopArea THEN
	    #IO_AreaFb.Alm.StopArea := TRUE;
	END_IF;
	
	//Generating alarm category feedback
	IF #i_Category = 1 AND #b_StaAlm THEN
	    #IO_AreaFb.Alm.Alm_Lvl1 := TRUE;
	END_IF;
	
	IF #i_Category = 2 AND #b_StaAlm THEN
	    #IO_AreaFb.Alm.Alm_Lvl2 := TRUE;
	END_IF;
	
	IF #i_Category = 3 AND #b_StaAlm THEN
	    #IO_AreaFb.Alm.Alm_Lvl3 := TRUE;
	END_IF;
	
	//============================================================================================
	IF (#Ob_Fwd <> #b_Old_ob_Fwd) OR (#Ob_Rev <> #b_Old_ob_Rev) THEN
	    #Odi_ActCouRst := #Odi_ActCouRst + 1;
	    #Odi_ActCouTot := #Odi_ActCouTot + 1;
	END_IF;
	IF #b_HmiCmdRstActOpe THEN
	    #Odi_ActCouRst := 0;
	END_IF;
	#b_Old_ob_Fwd := #Ob_Fwd;
	#b_Old_ob_Rev := #Ob_Rev;
	
	//============================================================================================
	//Local/Remote Operation
	IF #b_RemoteM AND #b_ManutLocal THEN
	    #b_RemoteM := FALSE;
	ELSIF NOT #b_RemoteM AND #b_ManutLocal THEN
	    #b_RemoteM := TRUE;
	END_IF;
	
	#Ob_LocRem := #b_RemoteM;
	
	//Local/Remote Operation
	IF #b_StaModMan AND NOT #b_StaModAut AND NOT #b_StaModDis THEN
	    #b_PerRemMod := TRUE;
	ELSE
	    #b_PerRemMod := FALSE;
	END_IF;
	
	//============================================================================================
	#FB_UTIL_Work_H_Rst(Ib_On := #Ob_Fwd OR #Ob_Rev,
	                    Ib_Reset := #b_HmiCmdRstActOpe,
	                    Ib_Pls1S := "Clock_1Hz",
	                    IOdi_ResultHours := #Odi_RunTimRst);
	
	#FB_UTIL_Work_H_Tot(Ib_On := #Ob_Fwd OR #Ob_Rev,
	                    Ib_Pls1S := "Clock_1Hz",
	                    IOdi_ResultHours := #Odi_RunTimTot);
END_FUNCTION_BLOCK

FUNCTION_BLOCK "G120C_Tel20"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT DB_SPECIFIC
      EM_Stop : Bool;   // 0 - parada de emergência ativa
      Release : Bool;   // Liberação do motor para operar
      Mode : Bool;   // 1 - Auto /0 - Manual
      Start_FW : Bool;   // Comando para avançar em automático
      Start_RV : Bool;   // Comando para recuar em automático
      Start_Man_FW : Bool;   // Comando para avançar em manual
      Start_MAN_RV : Bool;   // Comando para recuar em manual
      Reset : Bool;   // Reset de falhas do inversor
      SP : Real;   // Setpoint de velocidade do inversor em %
      SP_Man : Real;   // Setpoint de velocidade em modo manual do inversor em %
      G120_ZSW : Word;   // Status word do G120
      G120_NIST_A : Int;   // Velocidade atual do G120
      G120_IAIST : Int;   // Corrente atual do G120
      G120_MIST : Int;   // Torque atual do G120
      G120_F_Ref : Real;   // Referência do sinal de frequência
      G120_I_Ref : Real;   // Referência do sinal de corrente
      G120_T_Ref : Real;   // Referência do sinal de torque
   END_VAR

   VAR_OUTPUT DB_SPECIFIC
      Rdy_Start : Bool;   // Inversor ligado e inicializado
      Rdy : Bool;   // Inversor pronto para operar
      Enabled : Bool;   // Inversor seguindo o SP
      Fault : Bool;   // Inversor em falha
      OFF2 : Bool;   // Parada por inercia não ativa
      OFF3 : Bool;   // Parada rápida não ativa
      Alarm : Bool;   // Inversor em alarme
      SP_OK : Bool;   // Inversor está no SP
      Dir : Bool;   // 1 - Direto / 0 - Reverso
      EM_Fault : Bool;
      G120_STW : Word;   // Palavra de comando do inversor
      G120_NSOLL_A : Int;   // SP do inversor
      Freq : Real;   // Frequência atual do motor
      Curr : Real;   // Corrente atual do motor
      Torq : Real;   // Torque atual do motor
   END_VAR

   VAR_IN_OUT DB_SPECIFIC
      Lockout : Bool;
      Mater_Ctrl_Req : Bool;
      Max_Speed : Bool;
      FW_OK : Bool;
      RV_OK : Bool;
   END_VAR

   VAR_TEMP 
      Aux_Conv : Word;   // Auxiliar para converter word para bit e vice versa
      Aux_Int : Int;
      G120_STW_Aux : Word;   // Auxiliar para montar palavra de comando do inversor
      Aux_Conv_DI : DInt;   // Auxiliar para convertar 0 - 16X4000 para 0-100 e vice versa
      Aux_Conv_R : Real;   // Auxiliar para convertar 0 - 16X4000 para 0-100 e vice versa
      Temp : Int;
   END_VAR


BEGIN
	// =============================================================================================================================  
	// Purpose: G120C inverter telegram 20 communication block
	// -----------------------------------------------------------------------------------------------------------------------------
	// Date (dd MMM yyyy)   Developer                   Version   Comments/Reason for change
	// ..................   .........                   ....... ..........................
	// 22 Jan 2025          Gustavo Lourenção             01      Block language switch (Ladder to SCL)
	// 
	// -----------------------------------------------------------------------------------------------------------------------------
	// =============================================================================================================================
	//
	// ------------------------- ATENÇÃO* BLOCO COM O FUNCIONAMENTO AINDA NÃO VALIDADO, SE NÃO FUNCIONAR COPIE O G120C_TEL20 COM A LINGUAGEM LADDER---------------------
	
	#G120_STW_Aux := Int#0 ; //
	#G120_STW := #G120_STW_Aux; // copia palavra de comando
	
	// Detecta parada de emergencia e reseta a falha
	IF #EM_Stop THEN
	    // Statement section IF
	    #EM_Fault := 1;
	ELSIF #Reset THEN
	    #EM_Fault := 0;
	END_IF;
	
	
	#Rdy_Start := #G120_ZSW.%X0;
	#Rdy := #G120_ZSW.%X1;
	#Enabled := #G120_ZSW.%X2;
	#Fault := #G120_ZSW.%X3;
	#OFF2 := #G120_ZSW.%X4;
	#OFF3 := #G120_ZSW.%X5;
	#Lockout := #G120_ZSW.%X6;
	#Alarm := #G120_ZSW.%X7;
	#SP_OK := #G120_ZSW.%X8;
	#Mater_Ctrl_Req := #G120_ZSW.%X9;
	#Max_Speed := #G120_ZSW.%X10;
	#Dir := #G120_ZSW.%X14;
	
	
	#G120_STW_Aux.%X0 := #FW_OK OR #RV_OK; //OFF1 Ctr
	#G120_STW_Aux.%X1 := TRUE; //OFF 2 sempre ativo
	#G120_STW_Aux.%X2 := NOT #EM_Fault; //OFF3 (em caso de parada de emergência)
	#G120_STW_Aux.%X3 := #Release; //Enable (Release de operação)
	#G120_STW_Aux.%X4 :=
	#G120_STW_Aux.%X5 := TRUE; //Do not disable RFG/Enable RFG/ Enable SP/Control  (sempre ativo)
	#G120_STW_Aux.%X6 := TRUE; //Do not disable RFG/Enable RFG/ Enable SP/Control  (sempre ativo)
	#G120_STW_Aux.%X7 := #Reset;
	#G120_STW_Aux.%X8 :=
	#G120_STW_Aux.%X9 :=
	#G120_STW_Aux.%X10 :=
	#G120_STW_Aux.%X11 := #RV_OK AND NOT #FW_OK;
	#G120_STW_Aux.%X12 :=
	#G120_STW_Aux.%X13 :=
	#G120_STW_Aux.%X14 := TRUE; //Do not disable RFG/Enable RFG/ Enable SP/Control  (sempre ativo)
	#G120_STW_Aux.%X15 := FALSE;
	
	//Calcula SP auto para o inversor
	IF #Mode AND #SP >= 115.0 THEN
	    #G120_NSOLL_A := W#16#4000;
	END_IF;
	
	IF #Mode AND #SP <= 0 THEN
	    #G120_NSOLL_A := 0;
	END_IF;
	
	IF #Mode AND #SP > 0 AND #SP <= 115.0 THEN
	    #Aux_Conv_R := #SP * 163.84;
	END_IF;
	
	//Calcula #SP manual para inversor
	IF NOT #Mode AND #SP_Man >= 100.0 THEN
	    #Aux_Conv_R := 100.0;
	END_IF;
	
	IF NOT #Mode AND #SP_Man <= 0.0 THEN
	    #Aux_Conv_R := 0.0;
	END_IF;
	
	IF NOT #Mode AND #SP_Man > 0 AND #SP_Man <= 100.0 THEN
	    #Aux_Conv_R := #SP_Man * 163.84;
	END_IF;
	
	//converte SP e envia para drive
	#Aux_Conv_DI := ROUND(#Aux_Conv_R);
	#G120_NSOLL_A := #Aux_Conv_DI;
	
	//Converte sinal de Corrente
	#Aux_Conv_DI := INT_TO_DINT(#G120_NIST_A);
	#Aux_Conv_R := DINT_TO_REAL(#Aux_Conv_DI) / 16384.0;
	#Freq := #Aux_Conv_R * #G120_F_Ref;
	
	#Aux_Conv_DI := INT_TO_DINT(#G120_IAIST);
	#Aux_Conv_R := DINT_TO_REAL(#Aux_Conv_DI) / 16384.0;
	#Curr := #Aux_Conv_R * #G120_I_Ref;
	
	#Aux_Conv_DI := INT_TO_DINT(#G120_MIST);
	#Aux_Conv_R := DINT_TO_REAL(#Aux_Conv_DI) / 16384.0;
	#Torq := #Aux_Conv_R * #G120_T_Ref;
	
	//Start Fw
	#FW_OK := (#Mode AND #Start_FW) OR (NOT #Mode AND #Start_Man_FW) AND #Rdy_Start AND #OFF2 AND #OFF3 AND #Release AND #EM_Stop AND NOT #RV_OK AND NOT #Fault;
	
	//Start RV
	#RV_OK := (#Mode AND #Start_RV) OR (NOT #Mode AND #Start_MAN_RV) AND #Rdy_Start AND #OFF2 AND #OFF3 AND #Release AND #EM_Stop AND NOT #FW_OK AND NOT #Fault;
	
END_FUNCTION_BLOCK
